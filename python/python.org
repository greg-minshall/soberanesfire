* using python for gis things

#+property: header-args :noweb yes

** using [[https://pypi.python.org/pypi/Shapely][shapely]]

the [[toblerity.org/shapely/manual.html][manual]] looks promising.  shapely.wkt.loads(), shapely.wkt.dumps()
are what we need.

use ogrinfo to get wkt.  somehow slice it so it just includes the heat
perimeter.  then, read those into shapely:

#+BEGIN_SRC python :results output
from shapely import wkt

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

x1 = wkt.loads(f1.read())
x2 = wkt.loads(f2.read())

y2 = x2.difference(x1)
print y2
#+END_SRC

#+RESULTS:


then, export it somehow in kml format.

** using osgeo

[[https://pcjericks.github.io/py-gdalogr-cookbook/geometry.html][nice cookbook]]

#+BEGIN_SRC python :results output
from osgeo import ogr

wkt = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r").read()
pgons = ogr.CreateGeometryFromWkt(wkt)

kml = pgons.ExportToKML()
print kml

#+END_SRC

#+RESULTS:


** total flow?

read kml in osgeo, export to wkt1, import wkt1 to shapely, do
differences, export difference to wkt2, read wkt2 in osgeo, export to
kml.

*** extract-geom

so, 1 utility that extracts Heat Perimeter from a kml file, producing
a kml-geom file (to stdout)

*** diff-geom

1 utility that takes two kml-geom files, subtracts the second from the
first, writes the result as a kml-geom file (to stdout)

then, standard gump to glue the resulting files together to produce
the difference file.

#+BEGIN_SRC python :results output
from shapely import wkt
from osgeo import ogr

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

pgons1 = ogr.CreateGeometryFromWkt(f1.read())
pgons2 = ogr.CreateGeometryFromWkt(f2.read())

kml = pgons1.ExportToKML()
print kml

#+END_SRC

#+RESULTS:
: None

this prints the wkt of a layer/feature of a kml file

#+name: extractwkt.py
#+BEGIN_SRC python :tangle extractwkt.py
  from __future__ import print_function # for eprint() below

  import argparse
  import os
  import osgeo
  from osgeo import gdal
  from osgeo import ogr
  import sys

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="extract the well-known text (wkt) of a feature of a layer in a file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('ifile', type=str,
                          help="file to process")
      args = parser.parse_args();

      # make sure ifile is readable
      if not os.access(args.ifile, os.R_OK):
          eprint("input file '%s' cannot be read" % args.ifile)
          sys.exit(2)

      # get polygons from this file
      pgons = procfile(args.ifile, args.layername, args.featurename)
      # print(pgons)
      wkt = pgons.ExportToWkt()
      print(wkt)

  def procfile(filename, layername, featurename):
      """extract the polygon of a given feature in a given layer in a given file"""
      file = ogr.Open(filename)
      # print("this is %s data" % file.GetDriver().GetName())
      # print("there is/are %d layer(s)" % file.GetLayerCount())
      l = file.GetLayerByName(layername) # type(l) == OGRLayerH
      if l is None:
          eprint("layer '%s' is not found in file '%s'" % (layername, filename))
          sys.exit(3)
      l.ResetReading()
      # find the right feature
      found = False
      for featid in range(l.GetFeatureCount()):
          feature = l.GetFeature(featid); # type(feature) == OGRFeatureH
          fieldid = feature.GetFieldIndex("Name");
          name = feature.GetFieldAsString(fieldid);
          if (name == featurename):
              found = True
              break;
      if not found:
          eprint("feature name '%s' not found in layer '%s' in file '%s'" %
                 (featurename, layername, filename))
          sys.exit(3)
      # okay, we found the right feature.  now, find the polygon, maybe
      # a multigeometry
      geometry = feature.GetGeometryRef().Clone()
      return geometry

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

#+RESULTS:

#+name: differencewkt
#+BEGIN_SRC python :tangle differencewkt.py
  from __future__ import print_function # for eprint() below

  import argparse
  import os
  import osgeo
  from osgeo import gdal
  from osgeo import ogr
  import sys
  from shapely import wkt

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="compute the set-theoretic difference: fileA \\ fileB")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('fileA', type=argparse.FileType('r'),
                          help="base set")
      parser.add_argument('fileB', type=argparse.FileType('r'),
                          help="set to remove")
      args = parser.parse_args();

      geo1 = wkt.loads(args.fileA.read())
      geo2 = wkt.loads(args.fileB.read())

      print(geo1.is_valid)
      print(geo2.is_valid)
      geo3 = geo1.difference(geo2);

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

try to figure out what's going on

#+BEGIN_SRC python :results output
import shapely
import shapely.geometry

a = shapely.geometry.Point(1, 1).buffer(1.5)
b = shapely.geometry.Point(2,2).buffer(1.5)
c = a.difference(b)
c
#+END_SRC

#+RESULTS:

now, it turns out (see gis.org) that the exact way the IR data is
give, we can forget all about any of the GIS tools, and extract the
desired KML-bits with awk.  then, assuming Google Earth pays attention
to the order in which layers are defined, probably all will be good.

#+name: filelist
#+BEGIN_SRC sh :var root="/Users/minshall/work/gis/play/IR/" :var pat="doc.kml"
find ${root} -name ${pat} | sed sX^\./XXg | sort -n
#+END_SRC

#+RESULTS: filelist
| /Users/minshall/work/gis/play/IR//20160724_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160725_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160726_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160727_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160728_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160729_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160730_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160731_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160801_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160802_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160803_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160804_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160805_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160806_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160807_Soberanes_IR/doc.kml |
| /Users/minshall/work/gis/play/IR//20160808_Soberanes_IR/doc.kml |


#+name: extract_line
#+begin_src python
  def extract_line(file, trigger, select):
      """extract the first line matching SELECT that appears after the line matching TRIGGER"""
      import re
      f = open(file, 'r');
      for t in f:
          if (re.search(trigger, t)):
              for t in f:
                  if (re.search(select, t)):
                      return t;
#+end_src

#+BEGIN_SRC python :session py :var kmlfiles=filelist :var trigger="Heat Perimeter" :var select="Polygon" :results output verbatim
  <<extract_line>>

  import os
  kmls = []
  for file in kmlfiles:
      kmls = kmls + [extract_line(os.path.expanduser(file[0]), trigger, select)]

#+END_SRC

okay, because of the IR doc.kml files' format, we can do all this
without worrying much about GIS APIs.

#+name: fprolog1
#+BEGIN_EXAMPLE
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://earth.google.com/kml/2.0">
<Document><name><REPLACEME></name>
#+END_EXAMPLE

[[http://www.personal.psu.edu/cab38/ColorBrewer/ColorBrewer.html][Color Brewer]], 9-class sequential PuBu
#+name: colorbrewer
| 0xfff7fb | 0xece7f2 | 0xd0d1e6 | 0xa6bddb | 0x74a9cf | 0x3690c0 | 0x0570b0 | 0x045a8d | 0x023858 |

#+name: stylefrag
#+BEGIN_EXAMPLE
<Style id="style<FRAGID>">
  <LineStyle id="lineStyle<FRAGID>">
  <color>ff000000</color>
  <width>2</width>
  </LineStyle>
  <PolyStyle id="polyStyle<FRAGID>">
  <color><HEXVALUE></color>
  </PolyStyle>
</Style>
#+END_EXAMPLE

#+name: pprolog1
#+BEGIN_EXAMPLE
<Placemark><name><PLACEMARKNAME></name>
  <styleUrl>#style<FRAGID></styleUrl>
  <MultiGeometry><POLYGON>
#+END_EXAMPLE

#+name: ppost
#+BEGIN_EXAMPLE
</MultiGeometry></Placemark>
#+END_EXAMPLE


#+name: fpost
#+BEGIN_EXAMPLE
</Document>
</kml>
#+END_EXAMPLE


#+name: fprolog2
#+BEGIN_SRC python :var stylefrag=stylefrag :results output verbatim :cache yes
  <<colorsub>>
  <<fragsub>>

  print fragsub(0, colorsub('0xffffff', stylefrag))
#+END_SRC


#+name: colorsub
#+BEGIN_SRC python
  def colorsub(hexvalue, stylefrag):
      import re
      if type(hexvalue) is int:
          hvalue = hexvalue
      else:
          hvalue = int(hexvalue, base=16)
      return re.sub("<HEXVALUE>", "{0:x}".format(0x90000000 | hvalue), stylefrag)
#+END_SRC

#+name: fragsub
#+BEGIN_SRC python
  def fragsub(fragid, stylefrag):
      import re

      if type(fragid) is int:
          sfrag = str(fragid)
      else:
          sfrag = fragid
      return re.sub("<FRAGID>", sfrag, stylefrag)
#+END_SRC

colors can be found [[http://www.tayloredmktg.com/rgb/][here]].
#+name: fprolog2
#+BEGIN_SRC python :var stylefrag=stylefrag :results output verbatim :cache yes
  import re
  print re.sub("<FRAGID>", "0", re.sub("<HEXVALUE>", "0x900000dc", stylefrag))
#+END_SRC

#+name: fprolog3
#+BEGIN_SRC python :var colorbrewer=colorbrewer :var stylefrag=stylefrag :results output verbatim :cache yes
  <<colorsub>>
  <<fragsub>>

  for i in range(len(colorbrewer[0])):
      print fragsub(i+1, colorsub(colorbrewer[0][i], stylefrag))
#+END_SRC


#+name: fprolog4
#+BEGIN_SRC python :var stylefrag=stylefrag :results output :cache yes
<<colorsub>>
<<fragsub>>
print fragsub("N", colorsub(0x0000dc, stylefrag))
#+END_SRC

#+name: fprolog
#+BEGIN_SRC python :var a=fprolog1 :var b=fprolog2 :var c=fprolog3 :cache yes :results output verbatim
  print a, b, c
#+END_SRC


#+name: kmlfrags
#+BEGIN_SRC python :var a=pprolog1 :var c=ppost  :results output verbatim :cache yes
print a, c
#+END_SRC

#+name: fcomplete
#+BEGIN_SRC python :var fprolog=fprolog :var kmlfrags=kmlfrags :var fpost=fpost :results output verbatim
print fprolog, kmlfrags, fpost
#+END_SRC
