* using python for gis things
** intro

lots of code in this file hasn't really been developed.
extractwkt.py, awklike.py, and xpathusing.py are function (and the
last is what we are currently using).

[[http://stackoverflow.com/questions/101268/hidden-features-of-python][hidden features of python exposed!!]]

#+property: header-args :noweb yes

** caution

#+name: caution
#+BEGIN_SRC python
"""WARNING: THIS FILE IS PRODUCED BY python.org.  ANY CHANGES MADE HERE
WILL LIKELY BE LOST.  DO NOT MODIFY THIS FILE; RATHER, MODIFY python.org."""
#+END_SRC

** using [[https://pypi.python.org/pypi/Shapely][shapely]]

the [[toblerity.org/shapely/manual.html][manual]] looks promising.  shapely.wkt.loads(), shapely.wkt.dumps()
are what we need.

use ogrinfo to get wkt.  somehow slice it so it just includes the heat
perimeter.  then, read those into shapely:

#+BEGIN_SRC python :results output
from shapely import wkt

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

x1 = wkt.loads(f1.read())
x2 = wkt.loads(f2.read())

y2 = x2.difference(x1)
print y2
#+END_SRC

then, export it somehow in kml format.

[[http://deparkes.co.uk/2015/03/11/how-to-plot-polygons-in-python/][viewing polygons in python]]

#+BEGIN_SRC python :results output
import shapely
import shapely.geometry

a = shapely.geometry.Point(1, 1).buffer(1.5)
b = shapely.geometry.Point(2,2).buffer(1.5)
c = a.difference(b)
print c
#+END_SRC

#+name: herepoly
#+BEGIN_SRC python :session py  :tangle herepoly.py :results none :shebang "#!/usr/bin/env python"
  <<extractjson>>

  def herepoly(ijson):
      # from https://github.com/matplotlib/matplotlib/issues/5836
      import warnings;
      with warnings.catch_warnings():
          warnings.simplefilter("ignore"); 
          from matplotlib import pyplot
      import sys

      def getxy(*tuples):
          """return x,y from a pair (x,y) or triple (x,y,z)"""
          if len(tuples[0]) == 2:
              (x,y) = zip(*tuples)
          elif len(tuples[0]) == 3:
              (x,y,z) = zip(*tuples)
          else:
              raise ValueError("should have been a pair or triple, but was an {0}-tuple".format(len(tuples[0])))
          return (x,y)

      fig = pyplot.figure(1, figsize=(5,5), dpi=90)
      # for '111': http://stackoverflow.com/a/6981055/1527747
      # for 'aspect=1.0': http://stackoverflow.com/q/7965743/1527747
      ax = fig.add_subplot(111, aspect=1.0)
      if ijson['type'] == 'MultiPolygon':
          for pgon in range(len(ijson['coordinates'])):
              for lring in range(len(ijson['coordinates'][pgon])):
                  # zip(*zip): http://stackoverflow.com/q/2233204/1527747 and
                  # https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
                  # http://stackoverflow.com/a/2511319/1527747 ("it's (apply)")
                  (x,y) = getxy(*ijson['coordinates'][pgon][lring])
                  ignore = ax.plot(x, y, color='#000000', alpha=0.7,
                                   linewidth=1, solid_capstyle='round', zorder=2)
      elif ijson['type'] == 'Polygon':
          for lring in range(len(ijson['coordinates'])):
              # zip(*zip): http://stackoverflow.com/q/2233204/1527747 and
              # https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
              # http://stackoverflow.com/a/2511319/1527747 ("it's (apply)")
              (x,y) = getxy(*ijson['coordinates'][lring])
              ignore = ax.plot(x, y, color='#000000', alpha=0.7,
                               linewidth=1, solid_capstyle='round', zorder=2)
      else:
          # http://stackoverflow.com/a/24065533/1527747
          raise TypeError("type is '{0}', but we only support 'MultiPolygon' and 'Polygon'".format(ijson['type']))


      ignore = ax.set_title('Polygon')
      pyplot.show()

  def main(argv):
      import sys
      import argparse
      import json

      cmd = argv[0]
      parser = argparse.ArgumentParser(description=
                                       "plot a feature of a layer from an ogr-readable file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('filename', type=str, nargs=1)
      args = parser.parse_args();

      json = extractjson(args.filename[0], args.layername, args.featurename)

      herepoly(json)

  # file = "/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml"
  # layer = "Soberanes"
  # feature = "Heat Perimeter"
  # herepoly(file, layer, feature)

  if __name__ == "__main__":
      import sys
      main(sys.argv)
#+END_SRC

to get an arbitrary file/layer/feature into shapely, import FILE via
gdal/ogr, convert LAYER/FEATURE to WKT, then loads() that WKT.

#+BEGIN_SRC python :results output verbatim :session *py*
  import shapely.wkt

  <<extractwkt>>

  wkt = extractwkt("/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml",
      "Soberanes", "Heat Perimeter")

  sh = shapely.wkt.loads(wkt)
  for geom in sh.geoms:
      print(i.geom_type)
#+END_SRC

** using [[https://github.com/Toblerity/Fiona][fiona]]

[[http://www.macwright.org/2012/10/31/gis-with-python-shapely-fiona.html][here]] is a post on fiona.  it seems like fiona gives you a nicer
interface to the attributes than calling ogr directly.

sadly, fiona doesn't deal with the range of filetypes that ogr does,
in particular, it doesn't deal with kml.  but, we can import with
osgeo/ogr, then convert to Json, then, hopefully, feed that to fiona.

in fact, we don't need fiona at all, just (safely) eval the json.
(too bad fiona doesn't have an "import from string" function; i'd be
happier with that.)

#+BEGIN_SRC python :session *py* :results none
  import ast;                     # for ast.literal_eval
  <<featuregeometry>>

  file = "/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml"
  layer = "Soberanes"
  feature = "Heat Perimeter"

  geom = featuregeometry(file, layer, feature)
  # we could use plain eval(), but this is safer
  json = ast.literal_eval(geom.ExportToJson())

#+END_SRC

** using osgeo

[[https://pcjericks.github.io/py-gdalogr-cookbook/geometry.html][nice cookbook]]

#+BEGIN_SRC python :results output
  from osgeo import ogr

  wkt = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r").read()
  pgons = ogr.CreateGeometryFromWkt(wkt)

  kml = pgons.ExportToKML()
  print kml

#+END_SRC

** total flow?

read kml in osgeo, export to wkt1, import wkt1 to shapely, do
differences, export difference to wkt2, read wkt2 in osgeo, export to
kml.

*** extract-geom

so, 1 utility that extracts Heat Perimeter from a kml file, producing
a kml-geom file (to stdout)

*** diff-geom

1 utility that takes two kml-geom files, subtracts the second from the
first, writes the result as a kml-geom file (to stdout)

then, standard gump to glue the resulting files together to produce
the difference file.

#+BEGIN_SRC python :results output
from shapely import wkt
from osgeo import ogr

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

pgons1 = ogr.CreateGeometryFromWkt(f1.read())
pgons2 = ogr.CreateGeometryFromWkt(f2.read())

kml = pgons1.ExportToKML()
print kml

#+END_SRC

#+RESULTS:
: None

** featuregeometry

#+name: featuregeometry
#+BEGIN_SRC python :results none
  def featuregeometry(filename, layername, featurename):
        """extract the geometry of a given feature in a given layer in a given
  file"""
        import osgeo
        from osgeo import gdal
        from osgeo import ogr
        file = ogr.Open(filename)
        # print("this is %s data" % file.GetDriver().GetName())
        # print("there is/are %d layer(s)" % file.GetLayerCount())
        l = file.GetLayerByName(layername) # type(l) == OGRLayerH
        if l is None:
            raise NameError("layer '%s' is not found in file '%s'" % (layername, filename))
        l.ResetReading()
        # find the right feature
        found = False
        for featid in range(l.GetFeatureCount()):
              feature = l.GetFeature(featid); # type(feature) == OGRFeatureH
              fieldid = feature.GetFieldIndex("Name");
              name = feature.GetFieldAsString(fieldid);
              if (name == featurename):
                    found = True
                    break;
        if not found:
              raise NameError("feature name '%s' not found in layer '%s' in file '%s'" %
                     (featurename, layername, filename))
        # okay, we found the right feature.  now, find the polygon, maybe
        # a multigeometry
        geometry = feature.GetGeometryRef().Clone()
        return geometry
#+END_SRC

** extractwkt.py

this prints the wkt of a layer/feature of a kml file

#+name: extractwkt
#+BEGIN_SRC python
  <<featuregeometry>>

  def extractwkt(ifile, layername, featurename):
      """returns the WKT of the geometry of feature FEATURENAME in layer
      LAYERNAME in file FILE

      """
      # get polygons from this file
      pgons = featuregeometry(ifile, layername, featurename)
      # print(pgons)
      return(pgons.ExportToWkt())
#+END_SRC

#+RESULTS: extractwkt

#+name: extractgml
#+BEGIN_SRC python
  def extractgml(ifile, layername, featurename):
      """returns the GML of the geometry of feature FEATURENAME in layer
  LAYERNAME in file FILE

      """

      <<featuregeometry>>

      # get geometry from this file
      geom = featuregeometry(ifile, layername, featurename)
      return geom.ExportToGML()
#+END_SRC

#+name: extractjson
#+BEGIN_SRC python
  def extractjson(ifile, layername, featurename):
      """returns the WKT of the geometry of feature FEATURENAME in layer
      LAYERNAME in file FILE

      """
      import json

      <<featuregeometry>>

      # get polygons from this file
      geom = featuregeometry(ifile, layername, featurename)
      # print(geom)
      ijsonstr = geom.ExportToJson()
      return(json.loads(ijsonstr)) # now have a dict
#+END_SRC

#+BEGIN_SRC python :tangle extractwkt.py
  <<caution>>

  <<eprint>>

  import argparse
  import os
  import sys

  <<extractgml>>
  <<extractjson>>
  <<extractwkt>>

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="""extract the well-known text (wkt) of a feature of a layer in a file.  example usage:
      `python extractwkt.py -l Soberanes -f "Heat Perimeter" ~/work/gis/play/IR/20160729_Soberanes_IR/doc.kml\'""")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      parser.add_argument('-t', '--type', choices=['Wkt', 'Json', 'GML'], default='Wkt',
                          help="type of output [Wkt]")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('ifile', type=str, help="file to process")
      args = parser.parse_args();

      # make sure ifile is readable
      if not os.access(args.ifile, os.R_OK):
          eprint("input file '%s' cannot be read" % args.ifile)
          sys.exit(2)

      if (args.type == "Wkt"):
          print(extractwkt(args.ifile, args.layername, args.featurename))
      elif (args.type == "Json"):
          print(extractjson(args.ifile, args.layername, args.featurename))
      elif (args.type == "GML"):
          print(extractgml(args.ifile, args.layername, args.featurename))

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

** differencewkt.py

#+BEGIN_SRC python :tangle differencewkt.py
  <<caution>>

  from __future__ import print_function # for eprint() below

  import argparse
  import os
  import osgeo
  from osgeo import gdal
  from osgeo import ogr
  import sys
  from shapely import wkt

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="compute the set-theoretic difference: fileA \\ fileB")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('fileA', type=argparse.FileType('r'),
                          help="base set")
      parser.add_argument('fileB', type=argparse.FileType('r'),
                          help="set to remove")
      args = parser.parse_args();

      geo1 = wkt.loads(args.fileA.read())
      geo2 = wkt.loads(args.fileB.read())

      print(geo1.is_valid)
      print(geo2.is_valid)
      geo3 = geo1.difference(geo2);

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

** working code
*** common utility functions

***** eprint: print to stderr

this must be *first* (non-comment, non-blank) line in file.

#+name: eprint
#+BEGIN_SRC python
  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  from __future__ import print_function # for eprint() below
  import sys

  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)
#+END_SRC

***** colorsub

#+name: colorsub
#+BEGIN_SRC python
  def rgbtokml(rgb):
      """convert an rgb to kml's bgr"""

      r = (rgb/(256*256)) % 256
      g = (rgb/256) % 256
      b = rgb % 256
      bgr = (b*256*256)+(g*256)+(r)
      return bgr

  def colorsub(hexvalue, stylefrag):
      """insert an RGB value (really KML's BGR value) into a piece of text"""

      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(hexvalue) is int:
          hvalue = hexvalue
      else:
          hvalue = int(hexvalue, base=16)
      return re.sub("<HEXVALUE>", "{0:x}".format(0x90000000 | rgbtokml(hvalue)),
                    stylefrag)
#+END_SRC

***** fragsub

#+name: fragsub
#+BEGIN_SRC python
  def fragsub(fragid, stylefrag):
      """insert a fragment id into a kml fragment"""

      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(fragid) is int:
          sfrag = str(fragid)
      else:
          sfrag = fragid
      return re.sub("<FRAGID>", sfrag, stylefrag)
#+END_SRC

***** fprolog

#+name: fprolog
#+BEGIN_SRC python
  def fprolog2():
      return fragsub(0, colorsub(color0, stylefrag))

  def fprolog3():
      result = ""
      for i in range(len(colors)):
          result = "{0}{1}".format(result,
                                   fragsub(i+1, colorsub(colors[i], stylefrag)))
      return result

  def fprolog4():
      return fragsub("N", colorsub(colorN, stylefrag))

  def fprolog():
      """return the prolog to a fragment (one perimeter) of a file"""

      import re

      return "{0}\n{1}\n{2}\n{3}".format(re.sub("<DOCNAME>", layername, fprolog1),
                                         fprolog2(), fprolog3(), fprolog4())
#+END_SRC

***** kmlfrags

#+name: kmlfrags
#+BEGIN_SRC python
  def labelit(label):
      """we have N colors and M things to label; determine the correct 
  color for label number LABEL"""

      import math

      return int(math.ceil((1.0*ncolors/nkmls)*label))

  def kmlit(label, kml, fname):
      import re
      import math
      import os.path

      placemarkname = os.path.split(os.path.split(fname)[0])[1]

      if kml == None:
          return ""
      else:
          return re.sub("<POLYGON>", kml,
                        re.sub("<FRAGID>", str(label), 
                               re.sub("<PLACEMARKNAME>", placemarkname, pprolog1))) + ppost


  def kmlfrags():
      """do most of the processing: for each kml file, get the kml bits out
  of it, then generate the correct label for it (the first and last file
  have distinguished labels), and return the concatenation of it all"""

      global nkmls

      kmls = extract_kmls()
      nkmls = len(kmls)
      labels = [0]
      for i in range(1, len(kmls)-1):
          labels = labels + [labelit(i)]
      labels = labels + ["N"]
      result = ""
      # we run the list *backwards* so that newer (more expansive)
      # layers hide under older (more restricted) layers, to show the
      # growth day to day
      for i in list(reversed(range(len(kmls)))):
          kml = kmls[i]
          if kml != None:
              result = result+kmlit(labels[i], kml, kmlfiles[i])
      return result
#+END_SRC

***** file_fragments: string constants used by rest of code

colors can be found [[http://www.tayloredmktg.com/rgb/][here]].

#+name: file_fragments
#+BEGIN_SRC python
  fprolog1 = """<?xml version="1.0" encoding="UTF-8"?>
  <kml xmlns="http://earth.google.com/kml/2.0">
  <Document><name><DOCNAME></name>
  """

  color0 = 0xfcbba1
  # from http://www.personal.psu.edu/cab38/ColorBrewer/ColorBrewer.html
  # or http://colorbrewer2.org/
  # 9-class sequential PuBu
  colors = [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf,
            0x3690c0, 0x0570b0, 0x045a8d, 0x023858]
  ncolors = len(colors)
  colorN = 0xdc0000
  nkmls = 0

  stylefrag="""<Style id="style<FRAGID>">
  <LineStyle id="lineStyle<FRAGID>">
  <color>ff000000</color>
  <width>2</width>
  </LineStyle>
  <PolyStyle id="polyStyle<FRAGID>">
  <color><HEXVALUE></color>
  </PolyStyle>
  </Style>
  """

  pprolog1="""<Placemark><name><PLACEMARKNAME></name>
  <styleUrl>#style<FRAGID></styleUrl>
  <MultiGeometry><POLYGON>"""

  ppost="""</MultiGeometry></Placemark>
  """

  fpost="""</Document>
  </kml>
  """
#+END_SRC

*** awklike

--layername "Soberanes" --featurename "Heat Perimeter"

now, it turns out (see gis.org) that the exact way the IR data is
give, we can forget all about any of the GIS tools, and extract the
desired KML-bits with awk.  then, assuming Google Earth pays attention
to the order in which layers are defined, probably all will be good.

okay, because of the IR doc.kml files' format, we can do all this
without worrying much about GIS APIs, basically, it could be an awk
script.  unfortunately, when a new plane was put into service, the new
file formats didn't work for this.

#+BEGIN_SRC python :tangle awklike.py
  <<caution>>

  import sys

  <<file_fragments>>

  <<colorsub>>
  <<fragsub>>
  <<extract_kmls>>
  <<fprolog>>
  <<kmlfrags>>

  def extract_line(file, trigger, select):
      """extract the first line matching SELECT that appears after the
  line matching TRIGGER"""
      import re
      f = open(file, 'r');
      for t in f:
          if (re.search(trigger, t)):
              for t in f:
                  if (re.search(select, t)):
                      return t;

  def extract_kmls():
      import os
      kmls = []
      for file in kmlfiles:
          kmls = kmls + [extract_line(os.path.expanduser(file), featurename, select)]
      return kmls


  def main(argv):
      import argparse

      global layername, featurename, select, kmlfiles

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="reduce a feature of a layer from a number of KML files to a single KML file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
        # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      layername = args.layername
      featurename = args.featurename
      select = "Polygon"

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

*** parsing as an xml document

*** xml parsers we ended up not using for one reason or other

so, maybe i should break down and use some
[[https://docs.python.org/2/library/xml.html][python xml parser]].  but, which one?

***** [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]]

it [[http://stackoverflow.com/a/1912483/1527747][seems like]] [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]] is the way to parse.

this works for the first set of IR files for the Soberanes fire, but
not for the military-produced files.  possibly i need the full power
of xpath expressions (which i guess ElementTree doesn't provide).

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" :results output verbatim
  import xml.etree.ElementTree as et

  # set up namespace
  # http://stackoverflow.com/a/29021450/1527747
  et.register_namespace("","http://www.opengis.net/kml/2.2")
  ns = { "kml2.2": "http://www.opengis.net/kml/2.2" }

  tree = et.parse(input)
  root = tree.getroot()

  doc = root.find("kml2.2:Document", ns)

  places = doc.findall("kml2.2:Placemark", ns)

  # list comprehensions
  # https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
  hperil = [i for i in places if
            i.find("kml2.2:name", ns).text == "Heat Perimeter"]

  mg = hperil[0].find("kml2.2:MultiGeometry", ns)

  str = et.tostring(mg)
  print len(str)
#+END_SRC

#+RESULTS:
: 89305

***** [[https://github.com/stchris/untangle][untangle]]
but, [[https://github.com/stchris/untangle][untangle]] seems also nice.  so...
#+BEGIN_EXAMPLE
sudo pip install untangle
#+END_EXAMPLE
to install it

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" :results output verbatim
import untangle

kml = untangle.parse(input)

for i in kml.kml.Document:
  print i

#+END_SRC

#+RESULTS:

i'm not sure, though, how to get the raw contents of a subtree.

***** [[https://github.com/martinblech/xmltodict/blob/master/xmltodict.py][xmltodict]]

another simple parser.  allows unparse.

#+BEGIN_SRC python :results output verbatim
import xmltodict

input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" 

xd = xmltodict.parse(open(input))

print len(xd["kml"]["Document"].get('Placemark'))

#+END_SRC

this is nice.  but, really, probably need xpath expression support, in
order to allow user to specify the place(s) in the tree to pull out
the multigeometries.

***** [[https://docs.python.org/3/library/xml.dom.html][xml.dom]]

complicated?

*** xpathusing.py

okay, [[https://pypi.python.org/pypi/lxml/3.6.1][lxml]] works.  nicely.

to figure out the search term, an xml "flattener" is useful, such as
#+BEGIN_EXAMPLE
xml2 < ~/work/gis/play/IR/20160812_c0730_Soberanes_Aircraft3_All/doc.kml | less
#+END_EXAMPLE

a good simple reference for xpath expressions at [[http://www.w3schools.com/xsl/xpath_syntax.asp][w3schools.com]]

#+BEGIN_SRC python :tangle xpathusing.py :results output verbatim
  <<caution>>

  import sys

  <<file_fragments>>

  <<colorsub>>
  <<fragsub>>
  <<fprolog>>
  <<kmlfrags>>

  def extract_kmls():
      import os
      from lxml import etree

      kmls = []
      for file in kmlfiles:
          tree = etree.parse(file)
          extracts = tree.xpath(expr, namespaces=nspace)
          frags = ""
          for extract in extracts:
              frags = frags + etree.tostring(extract)
          kmls = kmls + [frags]
      return kmls


  def main(argv):
      import argparse

      global layername, nspace, expr, kmlfiles

      # namespace
      def_nsabbrev = "kml2.2"
      def_nslong = "http://www.opengis.net/kml/2.2"
      def_ns = { def_nsabbrev : def_nslong }

      def_expr = """
  //kml2.2:MultiGeometry[../kml2.2:name="Heat Perimeter"] |
  //kml2.2:MultiGeometry[../../kml2.2:name="Estimated Perimeter"] |
  //kml2.2:MultiGeometry[../../kml2.2:name="Fire Perimeter"]"""

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="take a number of geometry features from a group of kml files and produce one kml file")
      parser.add_argument('--nsabbrev', type=str, default=def_nsabbrev,
                          help='abbreviation for namespace (default: "{0}")'.format(def_nsabbrev))
      parser.add_argument('--nslong', type=str, default=def_nslong,
                          help='long name for namespace (default: "{0}")'.format(def_nslong))
      parser.add_argument('-e', '--expr', type=str, default=def_expr,
                          help='xpat expression (default is "{0}")'.format(def_expr))
      parser.add_argument('-l', '--layername', type=str, default="Soberanes",
                          help='name of desired layer (output file, default "Soberanes")')

      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      nspace =  {args.nsabbrev: args.nslong}
      layername = args.layername
      expr = args.expr

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)

#+END_SRC

here's an example of how to use:
#+BEGIN_EXAMPLE
python xpathusing.py `ls ~/work/gis/play/IR/20160???*Soberanes*/doc.kml | sort` 2>&1 > y.kml
#+END_EXAMPLE

** [[http://geoscript.org/][geoscript]]

a way of accessing JTS.  which, if GEOS is solely a downstream of JTS,
maybe closer is better...  related to [[http://www.geotools.org/][GeoTools]].  so, download geotools
(big) and (fink install) maven.  i needed to do
#+BEGIN_EXAMPLE
export JAVA_HOME=`/System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java_home`
#+END_EXAMPLE
to make it work.  then
#+BEGIN_EXAMPLE
C:java>  mvn archetype:generate -DgroupId=org.geotools -DartifactId=tutorial -Dversion=1.0-SNAPSHOT -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart
#+END_EXAMPLE

but, sigh, maybe it requires Java.  which i have, but ...

** playing

#+BEGIN_SRC python :results none :session py
import os, sys
import herepoly

js = {'type': 'Polygon', 'coordinates': [[[1208064.271243039, 614453.958118695], [1208064.271243039, 624154.6783778917], [1219317.1067437078, 624154.6783778917], [1219317.1067437078, 614453.958118695], [1208064.271243039, 614453.958118695]]]}
xs = herepoly.extractjson("x.gml", "Soberanes", "Heat Perimeter")

#+END_SRC
