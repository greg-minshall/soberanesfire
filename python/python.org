* using python for gis things

#+property: header-args :noweb yes

** using [[https://pypi.python.org/pypi/Shapely][shapely]]

the [[toblerity.org/shapely/manual.html][manual]] looks promising.  shapely.wkt.loads(), shapely.wkt.dumps()
are what we need.

use ogrinfo to get wkt.  somehow slice it so it just includes the heat
perimeter.  then, read those into shapely:

#+BEGIN_SRC python :results output
from shapely import wkt

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

x1 = wkt.loads(f1.read())
x2 = wkt.loads(f2.read())

y2 = x2.difference(x1)
print y2
#+END_SRC

#+RESULTS:


then, export it somehow in kml format.

** using osgeo

[[https://pcjericks.github.io/py-gdalogr-cookbook/geometry.html][nice cookbook]]

#+BEGIN_SRC python :results output
from osgeo import ogr

wkt = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r").read()
pgons = ogr.CreateGeometryFromWkt(wkt)

kml = pgons.ExportToKML()
print kml

#+END_SRC

#+RESULTS:


** total flow?

read kml in osgeo, export to wkt1, import wkt1 to shapely, do
differences, export difference to wkt2, read wkt2 in osgeo, export to
kml.

*** extract-geom

so, 1 utility that extracts Heat Perimeter from a kml file, producing
a kml-geom file (to stdout)

*** diff-geom

1 utility that takes two kml-geom files, subtracts the second from the
first, writes the result as a kml-geom file (to stdout)

then, standard gump to glue the resulting files together to produce
the difference file.

#+BEGIN_SRC python :results output
from shapely import wkt
from osgeo import ogr

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

pgons1 = ogr.CreateGeometryFromWkt(f1.read())
pgons2 = ogr.CreateGeometryFromWkt(f2.read())

kml = pgons1.ExportToKML()
print kml

#+END_SRC

#+RESULTS:
: None

this prints the wkt of a layer/feature of a kml file

#+name: extractwkt.py
#+BEGIN_SRC python :tangle extractwkt.py
  from __future__ import print_function # for eprint() below

  import argparse
  import os
  import osgeo
  from osgeo import gdal
  from osgeo import ogr
  import sys

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="extract the well-known text (wkt) of a feature of a layer in a file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('ifile', type=str,
                          help="file to process")
      args = parser.parse_args();

      # make sure ifile is readable
      if not os.access(args.ifile, os.R_OK):
          eprint("input file '%s' cannot be read" % args.ifile)
          sys.exit(2)

      # get polygons from this file
      pgons = procfile(args.ifile, args.layername, args.featurename)
      # print(pgons)
      wkt = pgons.ExportToWkt()
      print(wkt)

  def procfile(filename, layername, featurename):
      """extract the polygon of a given feature in a given layer in a given file"""
      file = ogr.Open(filename)
      # print("this is %s data" % file.GetDriver().GetName())
      # print("there is/are %d layer(s)" % file.GetLayerCount())
      l = file.GetLayerByName(layername) # type(l) == OGRLayerH
      if l is None:
          eprint("layer '%s' is not found in file '%s'" % (layername, filename))
          sys.exit(3)
      l.ResetReading()
      # find the right feature
      found = False
      for featid in range(l.GetFeatureCount()):
          feature = l.GetFeature(featid); # type(feature) == OGRFeatureH
          fieldid = feature.GetFieldIndex("Name");
          name = feature.GetFieldAsString(fieldid);
          if (name == featurename):
              found = True
              break;
      if not found:
          eprint("feature name '%s' not found in layer '%s' in file '%s'" %
                 (featurename, layername, filename))
          sys.exit(3)
      # okay, we found the right feature.  now, find the polygon, maybe
      # a multigeometry
      geometry = feature.GetGeometryRef().Clone()
      return geometry

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

#+RESULTS:

#+name: differencewkt
#+BEGIN_SRC python :tangle differencewkt.py
  from __future__ import print_function # for eprint() below

  import argparse
  import os
  import osgeo
  from osgeo import gdal
  from osgeo import ogr
  import sys
  from shapely import wkt

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="compute the set-theoretic difference: fileA \\ fileB")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('fileA', type=argparse.FileType('r'),
                          help="base set")
      parser.add_argument('fileB', type=argparse.FileType('r'),
                          help="set to remove")
      args = parser.parse_args();

      geo1 = wkt.loads(args.fileA.read())
      geo2 = wkt.loads(args.fileB.read())

      print(geo1.is_valid)
      print(geo2.is_valid)
      geo3 = geo1.difference(geo2);

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

try to figure out what's going on

#+BEGIN_SRC python :results output
import shapely
import shapely.geometry

a = shapely.geometry.Point(1, 1).buffer(1.5)
b = shapely.geometry.Point(2,2).buffer(1.5)
c = a.difference(b)
c
#+END_SRC

#+RESULTS:

now, it turns out (see gis.org) that the exact way the IR data is
give, we can forget all about any of the GIS tools, and extract the
desired KML-bits with awk.  then, assuming Google Earth pays attention
to the order in which layers are defined, probably all will be good.

#+name: filelist
#+BEGIN_SRC sh :var root="/Users/minshall/work/gis/play/IR/" :var pat="doc.kml"
find ${root} -name ${pat} | sed sX^\./XXg | sort -n
#+END_SRC

#+RESULTS: filelist
| /Users/minshall/work/gis/play/IR//20160724_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160725_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160726_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160727_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160728_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160729_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160730_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160731_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160801_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160802_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160803_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160804_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160805_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160806_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160807_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160808_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160809_Soberanes_IR/doc.kml                  |
| /Users/minshall/work/gis/play/IR//20160810_c0930_Soberanes_Aircraft3/doc.kml     |
| /Users/minshall/work/gis/play/IR//20160811_c0530_Soberanes_Aircraft3_All/doc.kml |


#+name: extract_line
#+begin_src python
  def extract_line(file, trigger, select):
      """extract the first line matching SELECT that appears after the line matching TRIGGER"""
      import re
      f = open(file, 'r');
      for t in f:
          if (re.search(trigger, t)):
              for t in f:
                  if (re.search(select, t)):
                      return t;
#+end_src

#+name: extract_kmls
#+BEGIN_SRC python
  <<extract_line>>

  def extract_kmls(kmlfiles, trigger, select):
      import os
      kmls = []
      for file in kmlfiles:
          kmls = kmls + [extract_line(os.path.expanduser(file), trigger, select)]
      return kmls
#+END_SRC


okay, because of the IR doc.kml files' format, we can do all this
without worrying much about GIS APIs.

#+name: colorsub
#+BEGIN_SRC python
  def rgbtokml(rgb):
      r = (rgb/(256*256)) % 256
      g = (rgb/256) % 256
      b = rgb % 256
      bgr = (b*256*256)+(g*256)+(r)
      return bgr

  def colorsub(hexvalue, stylefrag):
      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(hexvalue) is int:
          hvalue = hexvalue
      else:
          hvalue = int(hexvalue, base=16)
      return re.sub("<HEXVALUE>", "{0:x}".format(0x90000000 | rgbtokml(hvalue)),
                    stylefrag)
#+END_SRC

#+name: fragsub
#+BEGIN_SRC python
  def fragsub(fragid, stylefrag):
      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(fragid) is int:
          sfrag = str(fragid)
      else:
          sfrag = fragid
      return re.sub("<FRAGID>", sfrag, stylefrag)
#+END_SRC

colors can be found [[http://www.tayloredmktg.com/rgb/][here]].


--layername "Soberanes" --featurename "Heat Perimeter"

#+name: fcomplete
#+BEGIN_SRC python :tangle program.py
  from __future__ import print_function # for eprint() below

  import sys

  <<colorsub>>
  <<fragsub>>
  <<extract_kmls>>

  fprolog1 = """<?xml version="1.0" encoding="UTF-8"?>
  <kml xmlns="http://earth.google.com/kml/2.0">
  <Document><name><DOCNAME></name>
  """

  color0 = 0xffffff
  # from http://www.personal.psu.edu/cab38/ColorBrewer/ColorBrewer.html
  # 9-class sequential PuBu
  colors = [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf,
            0x3690c0, 0x0570b0, 0x045a8d, 0x023858]
  ncolors = len(colors)
  colorN = 0xdc0000
  nkmls = 0

  stylefrag="""<Style id="style<FRAGID>">
  <LineStyle id="lineStyle<FRAGID>">
  <color>ff000000</color>
  <width>2</width>
  </LineStyle>
  <PolyStyle id="polyStyle<FRAGID>">
  <color><HEXVALUE></color>
  </PolyStyle>
  </Style>
  """

  pprolog1="""<Placemark><name><PLACEMARKNAME></name>
  <styleUrl>#style<FRAGID></styleUrl>
  <MultiGeometry><POLYGON>"""

  ppost="""</MultiGeometry></Placemark>
  """

  fpost="""</Document>
  </kml>
  """

  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)


  def fprolog2():
      return fragsub(0, colorsub(color0, stylefrag))

  def fprolog3():
      result = ""
      for i in range(len(colors)):
          result = "{0}{1}".format(result,
                                   fragsub(i+1, colorsub(colors[i], stylefrag)))
      return result

  def fprolog4():
      return fragsub("N", colorsub(colorN, stylefrag))

  def fprolog():
      import re

      return "{0}\n{1}\n{2}\n{3}".format(re.sub("<DOCNAME>", layername, fprolog1),
                                         fprolog2(), fprolog3(), fprolog4())

  def labelit(label):
      import math

      return int(math.ceil((1.0*ncolors/nkmls)*label))

  def kmlit(label, kml, fname):
      import re
      import math
      import os.path

      placemarkname = os.path.split(os.path.split(fname)[0])[1]

      if kml == None:
          return ""
      else:
          return re.sub("<POLYGON>", kml,
                        re.sub("<FRAGID>", str(label), 
                               re.sub("<PLACEMARKNAME>", placemarkname, pprolog1))) + ppost


  def kmlfrags():
      global nkmls

      kmls = extract_kmls(kmlfiles, trigger, select)
      nkmls = len(kmls)
      labels = [0]
      for i in range(1, len(kmls)-1):
          labels = labels + [labelit(i)]
      labels = labels + ["N"]
      result = ""
      # we run the list *backwards* so that newer (more expansive)
      # layers hide under older layers, to show the growth day to day
      for i in list(reversed(range(len(kmls)))):
          kml = kmls[i]
          if kml != None:
              result = result+kmlit(labels[i], kml, kmlfiles[i])
      return result

  def main(argv):
      import argparse

      global layername, trigger, select, kmlfiles

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="reduce a feature of a layer from a number of KML files to a single KML file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
        # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      layername = args.layername
      trigger = args.featurename
      select = "Polygon"

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

*** parsing as an xml document

**** [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]]

it [[http://stackoverflow.com/a/1912483/1527747][seems like]] [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]] is the way to parse.

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160809_Soberanes_IR/doc.kml" :results output verbatim
import xml.etree.ElementTree as et
tree = et.parse(input)
root = tree.getroot()

#+END_SRC

**** [[https://github.com/stchris/untangle][untangle]]
but, [[https://github.com/stchris/untangle][untangle]] seems also nice.  so...
#+BEGIN_EXAMPLE
sudo pip install untangle
#+END_EXAMPLE
to install it

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160809_Soberanes_IR/doc.kml" :results output verbatim
import untangle

kml = untangle.parse(input)

for i in kml.Document:
  print i

#+END_SRC

i'm not sure, though, how to get the raw contents of a subtree.  also,
i don't seem to actually see the Polygon objects under MultiGeometry.
