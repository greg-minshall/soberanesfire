* using python for gis things

lots of code in this file hasn't really been developed.
extractwkt.py, awklike.py, and xpathusing.py are function (and the
last is what we are currently using).

#+property: header-args :noweb yes

** caution

#+name: caution
#+BEGIN_SRC python
"""WARNING: THIS FILE IS PRODUCED BY python.org.  ANY CHANGES MADE HERE
WILL LIKELY BE LOST.  DO NOT MODIFY THIS FILE; RATHER, MODIFY python.org."""
#+END_SRC

** using [[https://pypi.python.org/pypi/Shapely][shapely]]

the [[toblerity.org/shapely/manual.html][manual]] looks promising.  shapely.wkt.loads(), shapely.wkt.dumps()
are what we need.

use ogrinfo to get wkt.  somehow slice it so it just includes the heat
perimeter.  then, read those into shapely:

#+BEGIN_SRC python :results output
from shapely import wkt

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

x1 = wkt.loads(f1.read())
x2 = wkt.loads(f2.read())

y2 = x2.difference(x1)
print y2
#+END_SRC

#+RESULTS:


then, export it somehow in kml format.

[[http://deparkes.co.uk/2015/03/11/how-to-plot-polygons-in-python/][viewing polygons in python]]

#+BEGIN_SRC python :results output
import shapely
import shapely.geometry

a = shapely.geometry.Point(1, 1).buffer(1.5)
b = shapely.geometry.Point(2,2).buffer(1.5)
c = a.difference(b)
print c
#+END_SRC

#+RESULTS:
: POLYGON ((2.435413811199113 0.5645861888008871, 2.435410503598313 0.5645729841183068, 2.38581929876693 0.4259748514523659, 2.322881896522533 0.2929048947610042, 2.247204418453818 0.1666446504705974, 2.159515680044106 0.04841007375453255, 2.060660171779822 -0.06066017177982053, 1.951589926245469 -0.1595156800441044, 1.833355349529405 -0.2472044184538169, 1.707095105238998 -0.3228818965225317, 1.574025148547636 -0.3858192987669296, 1.435427015881695 -0.4354105035983127, 1.292635483024194 -0.4711779206048452, 1.147025710494343 -0.4927770900082951, 1.000000000000002 -0.5, 0.8529742895056617 -0.4927770900082955, 0.7073645169758103 -0.4711779206048461, 0.5645729841183093 -0.4354105035983142, 0.4259748514523682 -0.3858192987669313, 0.2929048947610065 -0.3228818965225342, 0.1666446504705994 -0.2472044184538196, 0.0484100737545341 -0.1595156800441073, -0.06066017177981919 -0.06066017177982341, -0.1595156800441035 0.04841007375452977, -0.2472044184538165 0.1666446504705945, -0.3228818965225315 0.2929048947610015, -0.3858192987669293 0.4259748514523634, -0.4354105035983127 0.5645729841183046, -0.4711779206048452 0.7073645169758058, -0.4927770900082953 0.8529742895056575, -0.5 0.9999999999999984, -0.4927770900082953 1.14702571049434, -0.4711779206048461 1.292635483024191, -0.4354105035983136 1.435427015881693, -0.3858192987669304 1.574025148547634, -0.3228818965225329 1.707095105238996, -0.2472044184538182 1.833355349529403, -0.1595156800441058 1.951589926245468, -0.06066017177982141 2.060660171779821, 0.0484100737545311 2.159515680044105, 0.1666446504705956 2.247204418453817, 0.292904894761002 2.322881896522532, 0.4259748514523632 2.385819298766929, 0.5645729841183038 2.435410503598312, 0.5645861888008867 2.435413811199113, 0.5288220793951539 2.292635483024191, 0.5072229099917047 2.14702571049434, 0.5 1.999999999999998, 0.5072229099917047 1.852974289505657, 0.5288220793951548 1.707364516975806, 0.5645894964016873 1.564572984118305, 0.6141807012330707 1.425974851452363, 0.6771181034774685 1.292904894761001, 0.7527955815461835 1.166644650470595, 0.8404843199558965 1.04841007375453, 0.9393398282201808 0.9393398282201766, 1.048410073754534 0.8404843199558927, 1.166644650470599 0.7527955815461804, 1.292904894761006 0.6771181034774658, 1.425974851452368 0.6141807012330687, 1.564572984118309 0.5645894964016858, 1.70736451697581 0.5288220793951539, 1.852974289505662 0.5072229099917045, 2.000000000000002 0.5, 2.147025710494343 0.5072229099917049, 2.292635483024195 0.5288220793951548, 2.435413811199113 0.5645861888008871))

** using osgeo

[[https://pcjericks.github.io/py-gdalogr-cookbook/geometry.html][nice cookbook]]

#+BEGIN_SRC python :results output
  from osgeo import ogr

  wkt = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r").read()
  pgons = ogr.CreateGeometryFromWkt(wkt)

  kml = pgons.ExportToKML()
  print kml

#+END_SRC

** total flow?

read kml in osgeo, export to wkt1, import wkt1 to shapely, do
differences, export difference to wkt2, read wkt2 in osgeo, export to
kml.

*** extract-geom

so, 1 utility that extracts Heat Perimeter from a kml file, producing
a kml-geom file (to stdout)

*** diff-geom

1 utility that takes two kml-geom files, subtracts the second from the
first, writes the result as a kml-geom file (to stdout)

then, standard gump to glue the resulting files together to produce
the difference file.

#+BEGIN_SRC python :results output
from shapely import wkt
from osgeo import ogr

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

pgons1 = ogr.CreateGeometryFromWkt(f1.read())
pgons2 = ogr.CreateGeometryFromWkt(f2.read())

kml = pgons1.ExportToKML()
print kml

#+END_SRC

#+RESULTS:
: None

** extractwkt.py

this prints the wkt of a layer/feature of a kml file

#+BEGIN_SRC python :tangle extractwkt.py
  <<caution>>

  from __future__ import print_function # for eprint() below

  import argparse
  import os
  import osgeo
  from osgeo import gdal
  from osgeo import ogr
  import sys

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="""extract the well-known text (wkt) of a feature of a layer in a file.  example usage:
      `python extractwkt.py -l Soberanes -f "Heat Perimeter" ~/work/gis/play/IR/20160729_Soberanes_IR/doc.kml\'""")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('ifile', type=str,
                          help="file to process")
      args = parser.parse_args();

      # make sure ifile is readable
      if not os.access(args.ifile, os.R_OK):
          eprint("input file '%s' cannot be read" % args.ifile)
          sys.exit(2)

      # get polygons from this file
      pgons = procfile(args.ifile, args.layername, args.featurename)
      # print(pgons)
      wkt = pgons.ExportToWkt()
      print(wkt)

  def procfile(filename, layername, featurename):
      """extract the polygon of a given feature in a given layer in a given file"""
      file = ogr.Open(filename)
      # print("this is %s data" % file.GetDriver().GetName())
      # print("there is/are %d layer(s)" % file.GetLayerCount())
      l = file.GetLayerByName(layername) # type(l) == OGRLayerH
      if l is None:
          eprint("layer '%s' is not found in file '%s'" % (layername, filename))
          sys.exit(3)
      l.ResetReading()
      # find the right feature
      found = False
      for featid in range(l.GetFeatureCount()):
          feature = l.GetFeature(featid); # type(feature) == OGRFeatureH
          fieldid = feature.GetFieldIndex("Name");
          name = feature.GetFieldAsString(fieldid);
          if (name == featurename):
              found = True
              break;
      if not found:
          eprint("feature name '%s' not found in layer '%s' in file '%s'" %
                 (featurename, layername, filename))
          sys.exit(3)
      # okay, we found the right feature.  now, find the polygon, maybe
      # a multigeometry
      geometry = feature.GetGeometryRef().Clone()
      return geometry

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

** differencewkt.py

#+BEGIN_SRC python :tangle differencewkt.py
  <<caution>>

  from __future__ import print_function # for eprint() below

  import argparse
  import os
  import osgeo
  from osgeo import gdal
  from osgeo import ogr
  import sys
  from shapely import wkt

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="compute the set-theoretic difference: fileA \\ fileB")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('fileA', type=argparse.FileType('r'),
                          help="base set")
      parser.add_argument('fileB', type=argparse.FileType('r'),
                          help="set to remove")
      args = parser.parse_args();

      geo1 = wkt.loads(args.fileA.read())
      geo2 = wkt.loads(args.fileB.read())

      print(geo1.is_valid)
      print(geo2.is_valid)
      geo3 = geo1.difference(geo2);

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

** working code
*** common utility functions

***** eprint: print to stderr

this must be *first* (non-comment, non-blank) line in file.

#+name: eprint
#+BEGIN_SRC python
  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  from __future__ import print_function # for eprint() below

  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)
#+END_SRC

***** colorsub

#+name: colorsub
#+BEGIN_SRC python
  def rgbtokml(rgb):
      """convert an rgb to kml's bgr"""

      r = (rgb/(256*256)) % 256
      g = (rgb/256) % 256
      b = rgb % 256
      bgr = (b*256*256)+(g*256)+(r)
      return bgr

  def colorsub(hexvalue, stylefrag):
      """insert an RGB value (really KML's BGR value) into a piece of text"""

      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(hexvalue) is int:
          hvalue = hexvalue
      else:
          hvalue = int(hexvalue, base=16)
      return re.sub("<HEXVALUE>", "{0:x}".format(0x90000000 | rgbtokml(hvalue)),
                    stylefrag)
#+END_SRC

***** fragsub

#+name: fragsub
#+BEGIN_SRC python
  def fragsub(fragid, stylefrag):
      """insert a fragment id into a kml fragment"""

      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(fragid) is int:
          sfrag = str(fragid)
      else:
          sfrag = fragid
      return re.sub("<FRAGID>", sfrag, stylefrag)
#+END_SRC

***** fprolog

#+name: fprolog
#+BEGIN_SRC python
  def fprolog2():
      return fragsub(0, colorsub(color0, stylefrag))

  def fprolog3():
      result = ""
      for i in range(len(colors)):
          result = "{0}{1}".format(result,
                                   fragsub(i+1, colorsub(colors[i], stylefrag)))
      return result

  def fprolog4():
      return fragsub("N", colorsub(colorN, stylefrag))

  def fprolog():
      """return the prolog to a fragment (one perimeter) of a file"""

      import re

      return "{0}\n{1}\n{2}\n{3}".format(re.sub("<DOCNAME>", layername, fprolog1),
                                         fprolog2(), fprolog3(), fprolog4())
#+END_SRC

***** kmlfrags

#+name: kmlfrags
#+BEGIN_SRC python
  def labelit(label):
      """we have N colors and M things to label; determine the correct 
  color for label number LABEL"""

      import math

      return int(math.ceil((1.0*ncolors/nkmls)*label))

  def kmlit(label, kml, fname):
      import re
      import math
      import os.path

      placemarkname = os.path.split(os.path.split(fname)[0])[1]

      if kml == None:
          return ""
      else:
          return re.sub("<POLYGON>", kml,
                        re.sub("<FRAGID>", str(label), 
                               re.sub("<PLACEMARKNAME>", placemarkname, pprolog1))) + ppost


  def kmlfrags():
      """do most of the processing: for each kml file, get the kml bits out
  of it, then generate the correct label for it (the first and last file
  have distinguished labels), and return the concatenation of it all"""

      global nkmls

      kmls = extract_kmls()
      nkmls = len(kmls)
      labels = [0]
      for i in range(1, len(kmls)-1):
          labels = labels + [labelit(i)]
      labels = labels + ["N"]
      result = ""
      # we run the list *backwards* so that newer (more expansive)
      # layers hide under older (more restricted) layers, to show the
      # growth day to day
      for i in list(reversed(range(len(kmls)))):
          kml = kmls[i]
          if kml != None:
              result = result+kmlit(labels[i], kml, kmlfiles[i])
      return result
#+END_SRC

***** file_fragments: string constants used by rest of code

colors can be found [[http://www.tayloredmktg.com/rgb/][here]].

#+name: file_fragments
#+BEGIN_SRC python
  fprolog1 = """<?xml version="1.0" encoding="UTF-8"?>
  <kml xmlns="http://earth.google.com/kml/2.0">
  <Document><name><DOCNAME></name>
  """

  color0 = 0xffffff
  # from http://www.personal.psu.edu/cab38/ColorBrewer/ColorBrewer.html
  # 9-class sequential PuBu
  colors = [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf,
            0x3690c0, 0x0570b0, 0x045a8d, 0x023858]
  ncolors = len(colors)
  colorN = 0xdc0000
  nkmls = 0

  stylefrag="""<Style id="style<FRAGID>">
  <LineStyle id="lineStyle<FRAGID>">
  <color>ff000000</color>
  <width>2</width>
  </LineStyle>
  <PolyStyle id="polyStyle<FRAGID>">
  <color><HEXVALUE></color>
  </PolyStyle>
  </Style>
  """

  pprolog1="""<Placemark><name><PLACEMARKNAME></name>
  <styleUrl>#style<FRAGID></styleUrl>
  <MultiGeometry><POLYGON>"""

  ppost="""</MultiGeometry></Placemark>
  """

  fpost="""</Document>
  </kml>
  """
#+END_SRC

*** awklike

--layername "Soberanes" --featurename "Heat Perimeter"

now, it turns out (see gis.org) that the exact way the IR data is
give, we can forget all about any of the GIS tools, and extract the
desired KML-bits with awk.  then, assuming Google Earth pays attention
to the order in which layers are defined, probably all will be good.

okay, because of the IR doc.kml files' format, we can do all this
without worrying much about GIS APIs, basically, it could be an awk
script.  unfortunately, when a new plane was put into service, the new
file formats didn't work for this.

#+BEGIN_SRC python :tangle awklike.py
  <<caution>>

  <<eprint>>                      # must be first
  import sys

  <<file_fragments>>

  <<colorsub>>
  <<fragsub>>
  <<extract_kmls>>
  <<fprolog>>
  <<kmlfrags>>

  def extract_line(file, trigger, select):
      """extract the first line matching SELECT that appears after the
  line matching TRIGGER"""
      import re
      f = open(file, 'r');
      for t in f:
          if (re.search(trigger, t)):
              for t in f:
                  if (re.search(select, t)):
                      return t;

  def extract_kmls():
      import os
      kmls = []
      for file in kmlfiles:
          kmls = kmls + [extract_line(os.path.expanduser(file), featurename, select)]
      return kmls


  def main(argv):
      import argparse

      global layername, featurename, select, kmlfiles

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="reduce a feature of a layer from a number of KML files to a single KML file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
        # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      layername = args.layername
      featurename = args.featurename
      select = "Polygon"

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

*** parsing as an xml document

*** xml parsers we ended up not using for one reason or other

so, maybe i should break down and use some
[[https://docs.python.org/2/library/xml.html][python xml parser]].  but, which one?

***** [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]]

it [[http://stackoverflow.com/a/1912483/1527747][seems like]] [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]] is the way to parse.

this works for the first set of IR files for the Soberanes fire, but
not for the military-produced files.  possibly i need the full power
of xpath expressions (which i guess ElementTree doesn't provide).

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" :results output verbatim
  import xml.etree.ElementTree as et

  # set up namespace
  # http://stackoverflow.com/a/29021450/1527747
  et.register_namespace("","http://www.opengis.net/kml/2.2")
  ns = { "kml2.2": "http://www.opengis.net/kml/2.2" }

  tree = et.parse(input)
  root = tree.getroot()

  doc = root.find("kml2.2:Document", ns)

  places = doc.findall("kml2.2:Placemark", ns)

  # list comprehensions
  # https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
  hperil = [i for i in places if
            i.find("kml2.2:name", ns).text == "Heat Perimeter"]

  mg = hperil[0].find("kml2.2:MultiGeometry", ns)

  str = et.tostring(mg)
  print len(str)
#+END_SRC

#+RESULTS:
: 89305

***** [[https://github.com/stchris/untangle][untangle]]
but, [[https://github.com/stchris/untangle][untangle]] seems also nice.  so...
#+BEGIN_EXAMPLE
sudo pip install untangle
#+END_EXAMPLE
to install it

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" :results output verbatim
import untangle

kml = untangle.parse(input)

for i in kml.kml.Document:
  print i

#+END_SRC

#+RESULTS:

i'm not sure, though, how to get the raw contents of a subtree.

***** [[https://github.com/martinblech/xmltodict/blob/master/xmltodict.py][xmltodict]]

another simple parser.  allows unparse.

#+BEGIN_SRC python :results output verbatim
import xmltodict

input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" 

xd = xmltodict.parse(open(input))

print len(xd["kml"]["Document"].get('Placemark'))

#+END_SRC

this is nice.  but, really, probably need xpath expression support, in
order to allow user to specify the place(s) in the tree to pull out
the multigeometries.

***** [[https://docs.python.org/3/library/xml.dom.html][xml.dom]]

complicated?

*** xpathusing.py

okay, [[https://pypi.python.org/pypi/lxml/3.6.1][lxml]] works.  nicely.

to figure out the search term, an xml "flattener" is useful, such as
#+BEGIN_EXAMPLE
xml2 < ~/work/gis/play/IR/20160812_c0730_Soberanes_Aircraft3_All/doc.kml | less
#+END_EXAMPLE

a good simple reference for xpath expressions at [[http://www.w3schools.com/xsl/xpath_syntax.asp][w3schools.com]]

#+BEGIN_SRC python :tangle xpathusing.py :results output verbatim
  <<caution>>

  <<eprint>>                      # must be first
  import sys

  <<file_fragments>>

  <<colorsub>>
  <<fragsub>>
  <<fprolog>>
  <<kmlfrags>>

  def extract_kmls():
      import os
      from lxml import etree

      kmls = []
      for file in kmlfiles:
          tree = etree.parse(file)
          extracts = tree.xpath(expr, namespaces=nspace)
          frags = ""
          for extract in extracts:
              frags = frags + etree.tostring(extract)
          kmls = kmls + [frags]
      return kmls


  def main(argv):
      import argparse

      global layername, nspace, expr, kmlfiles

      # namespace
      def_nsabbrev = "kml2.2"
      def_nslong = "http://www.opengis.net/kml/2.2"
      def_ns = { def_nsabbrev : def_nslong }

      def_expr = """
  //kml2.2:MultiGeometry[../kml2.2:name="Heat Perimeter"] |
  //kml2.2:MultiGeometry[../../kml2.2:name="Estimated Perimeter"] |
  //kml2.2:MultiGeometry[../../kml2.2:name="Fire Perimeter"]"""

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="take a number of geometry features from a group of kml files and produce one kml file")
      parser.add_argument('--nsabbrev', type=str, default=def_nsabbrev,
                          help='abbreviation for namespace (default: "{0}")'.format(def_nsabbrev))
      parser.add_argument('--nslong', type=str, default=def_nslong,
                          help='long name for namespace (default: "{0}")'.format(def_nslong))
      parser.add_argument('-e', '--expr', type=str, default=def_expr,
                          help='xpat expression (default is "{0}")'.format(def_expr))
      parser.add_argument('-l', '--layername', type=str, default="Soberanes",
                          help='name of desired layer (output file, default "Soberanes")')

      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      nspace =  {args.nsabbrev: args.nslong}
      layername = args.layername
      expr = args.expr

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)

#+END_SRC

here's an example of how to use:
#+BEGIN_EXAMPLE
python xpathusing.py `ls ~/work/gis/play/IR/20160???*Soberanes*/doc.kml | sort` 2>&1 > y.kml
#+END_EXAMPLE
