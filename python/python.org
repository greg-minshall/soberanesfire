* using python for gis things
** intro

lots of code in this file hasn't really been developed.
extractwkt.py, awklike.py, and xpathusing.py are function (and the
last is what we are currently using).

[[http://stackoverflow.com/questions/101268/hidden-features-of-python][hidden features of python exposed!!]]

#+property: header-args :noweb yes

** caution

#+name: caution
#+BEGIN_SRC python
"""WARNING: THIS FILE IS PRODUCED BY python.org.  ANY CHANGES MADE HERE
WILL LIKELY BE LOST.  DO NOT MODIFY THIS FILE; RATHER, MODIFY python.org."""
#+END_SRC

** using [[https://pypi.python.org/pypi/Shapely][shapely]]

the [[toblerity.org/shapely/manual.html][manual]] looks promising.  shapely.wkt.loads(), shapely.wkt.dumps()
are what we need.

use ogrinfo to get wkt.  somehow slice it so it just includes the heat
perimeter.  then, read those into shapely:

#+BEGIN_SRC python :results output
from shapely import wkt

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

x1 = wkt.loads(f1.read())
x2 = wkt.loads(f2.read())

y2 = x2.difference(x1)
print y2
#+END_SRC

then, export it somehow in kml format.

[[http://deparkes.co.uk/2015/03/11/how-to-plot-polygons-in-python/][viewing polygons in python]]

#+BEGIN_SRC python :results output
import shapely
import shapely.geometry

a = shapely.geometry.Point(1, 1).buffer(1.5)
b = shapely.geometry.Point(2,2).buffer(1.5)
c = a.difference(b)
print c
#+END_SRC


#+name: shPolyJson
#+BEGIN_SRC python
  def shPolyJson(ijson):
      """plot the *exterior*** of a geojson polygon (using matplotlib)"""

      # from https://github.com/matplotlib/matplotlib/issues/5836
      import warnings;
      with warnings.catch_warnings():
          warnings.simplefilter("ignore");
          from matplotlib import pyplot
      import sys

      def getxy(*tuples):
          """return x,y from a pair (x,y) or triple (x,y,z)"""
          if len(tuples[0]) == 2:
              (x,y) = zip(*tuples)
          elif len(tuples[0]) == 3:
              (x,y,z) = zip(*tuples)
          else:
              raise ValueError("should have been a pair or triple, but was an {0}-tuple".format(len(tuples[0])))
          return (x,y)

      fig = pyplot.figure(1, figsize=(5,5), dpi=90)
      # for '111': http://stackoverflow.com/a/6981055/1527747
      # for 'aspect=1.0': http://stackoverflow.com/q/7965743/1527747
      ax = fig.add_subplot(111, aspect=1.0)
      if ijson['type'] == 'MultiPolygon':
          for pgon in range(len(ijson['coordinates'])):
              for lring in range(len(ijson['coordinates'][pgon])):
                  # zip(*zip): http://stackoverflow.com/q/2233204/1527747 and
                  # https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
                  # http://stackoverflow.com/a/2511319/1527747 ("it's (apply)")
                  (x,y) = getxy(*ijson['coordinates'][pgon][lring])
                  ignore = ax.plot(x, y, color='#000000', alpha=0.7,
                                   linewidth=1, solid_capstyle='round', zorder=2)
      elif ijson['type'] == 'Polygon':
          for lring in range(len(ijson['coordinates'])):
              # zip(*zip): http://stackoverflow.com/q/2233204/1527747 and
              # https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
              # http://stackoverflow.com/a/2511319/1527747 ("it's (apply)")
              (x,y) = getxy(*ijson['coordinates'][lring])
              ignore = ax.plot(x, y, color='#000000', alpha=0.7,
                               linewidth=1, solid_capstyle='round', zorder=2)
      else:
          # http://stackoverflow.com/a/24065533/1527747
          raise TypeError("type is '{0}', but we only support 'MultiPolygon' and 'Polygon'".format(ijson['type']))


      ignore = ax.set_title('Polygon')
      pyplot.show()
#+END_SRC

#+name: shPolyShape
#+BEGIN_SRC python
  <<GpShape>>
  def shPolyShape(shape, device=None):
      """prints the *EXTERIOR* of SHAPE)""" # XXX to interior cutouts

      gp = GpShape(device)
      gp.add(shape)
      gp.plot()

#+END_SRC

#+name: shPoly
#+BEGIN_SRC python :session py  :tangle shpoly :results none :shebang "#!/usr/bin/env python"
  import os

  <<extractshape>>
  <<GpShape>>

  def main(argv):
      import os, sys
      import argparse

      cmd = argv[0]
      parser = argparse.ArgumentParser(description=
                                       "plot a feature of a layer from an ogr-readable file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      parser.add_argument('--device', type=str, default=None,
                          help='device on which to plot (gnuplot "set terminal")')
      parser.add_argument('--output', type=str, default=None,
                          help="name of output file (for device=png, etc.)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('filename', type=str, nargs=1)
      args = parser.parse_args();

      gp = GpShape(args.device)
      if (args.output):
          gp.write('set output "{0}"'.format(args.output))
      shape = extractshape(args.filename[0], args.layername, args.featurename)

      gp.add(shape)
      gp.plot()

  # file = "/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml"
  # layer = "Soberanes"
  # feature = "Heat Perimeter"
  # shPoly(file, layer, feature)

  if __name__ == "__main__":
      import sys
      main(sys.argv)
#+END_SRC

to get an arbitrary file/layer/feature into shapely, import FILE via
gdal/ogr, convert LAYER/FEATURE to WKT, then loads() that WKT.

#+BEGIN_SRC python :results output verbatim :session *py*
  import shapely.wkt

  <<extractwkt>>

  wkt = extractwkt("/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml",
      "Soberanes", "Heat Perimeter")

  sh = shapely.wkt.loads(wkt)
  for geom in sh.geoms:
      print(i.geom_type)
#+END_SRC

** using [[https://github.com/Toblerity/Fiona][fiona]]

[[http://www.macwright.org/2012/10/31/gis-with-python-shapely-fiona.html][here]] is a post on fiona.  it seems like fiona gives you a nicer
interface to the attributes than calling ogr directly.

sadly, fiona doesn't deal with the range of filetypes that ogr does,
in particular, it doesn't deal with kml.  but, we can import with
osgeo/ogr, then convert to Json, then, hopefully, feed that to fiona.

in fact, we don't need fiona at all, just (safely) eval the json.
(too bad fiona doesn't have an "import from string" function; i'd be
happier with that.)

#+BEGIN_SRC python :session *py* :results none
  import ast;                     # for ast.literal_eval
  <<featuregeometry>>

  file = "/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml"
  layer = "Soberanes"
  feature = "Heat Perimeter"

  geom = featuregeometry(file, layer, feature)
  # we could use plain eval(), but this is safer
  json = ast.literal_eval(geom.ExportToJson())

#+END_SRC

** using osgeo

[[https://pcjericks.github.io/py-gdalogr-cookbook/geometry.html][nice cookbook]]

#+BEGIN_SRC python :results output
  from osgeo import ogr

  wkt = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r").read()
  pgons = ogr.CreateGeometryFromWkt(wkt)

  kml = pgons.ExportToKML()
  print kml

#+END_SRC

** total flow?

read kml in osgeo, export to wkt1, import wkt1 to shapely, do
differences, export difference to wkt2, read wkt2 in osgeo, export to
kml.

*** extract-geom

so, 1 utility that extracts Heat Perimeter from a kml file, producing
a kml-geom file (to stdout)

*** diff-geom

1 utility that takes two kml-geom files, subtracts the second from the
first, writes the result as a kml-geom file (to stdout)

then, standard gump to glue the resulting files together to produce
the difference file.

#+BEGIN_SRC python :results output
from shapely import wkt
from osgeo import ogr

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

pgons1 = ogr.CreateGeometryFromWkt(f1.read())
pgons2 = ogr.CreateGeometryFromWkt(f2.read())

kml = pgons1.ExportToKML()
print kml

#+END_SRC

#+RESULTS:
: None

** featuregeometry

#+name: featuregeometry
#+BEGIN_SRC python :results none
  def featuregeometry(filename, layername, featurename):
        """extract the geometry of a given feature in a given layer in a given
  file"""
        import osgeo
        from osgeo import gdal
        from osgeo import ogr

        file = ogr.Open(filename)
        # print("this is %s data" % file.GetDriver().GetName())
        # print("there is/are %d layer(s)" % file.GetLayerCount())
        l = file.GetLayerByName(layername) # type(l) == OGRLayerH
        if l is None:
            raise NameError("layer '%s' is not found in file '%s'" % (layername, filename))
        l.ResetReading()
        # find the right feature
        found = False
        for featid in range(l.GetFeatureCount()):
              feature = l.GetFeature(featid); # type(feature) == OGRFeatureH
              fieldid = feature.GetFieldIndex("Name");
              name = feature.GetFieldAsString(fieldid);
              if (name == featurename):
                    found = True
                    break;
        if not found:
              raise NameError("feature name '%s' not found in layer '%s' in file '%s'" %
                     (featurename, layername, filename))
        # okay, we found the right feature.  now, find the polygon, maybe
        # a multigeometry
        geometry = feature.GetGeometryRef().Clone()
        return geometry
#+END_SRC

** extractwkt.py

this prints the wkt of a layer/feature of a kml file

#+name: extractwkt
#+BEGIN_SRC python
  <<featuregeometry>>

  def extractwkt(ifile, layername, featurename):
      """returns the WKT of the geometry of feature FEATURENAME in layer
      LAYERNAME in file FILE

      """
      # get polygons from this file
      pgons = featuregeometry(ifile, layername, featurename)
      # print(pgons)
      return(pgons.ExportToWkt())
#+END_SRC

#+RESULTS: extractwkt

#+name: extractgml
#+BEGIN_SRC python
  def extractgml(ifile, layername, featurename):
      """returns the GML of the geometry of feature FEATURENAME in layer
  LAYERNAME in file FILE

      """

      <<featuregeometry>>

      # get geometry from this file
      geom = featuregeometry(ifile, layername, featurename)
      return geom.ExportToGML()
#+END_SRC

#+name: extractjson
#+BEGIN_SRC python
  def extractjson(ifile, layername, featurename):
      """returns the WKT of the geometry of feature FEATURENAME in layer
      LAYERNAME in file FILE

      """
      import geojson

      <<featuregeometry>>

      # get polygons from this file
      geom = featuregeometry(ifile, layername, featurename)
      # print(geom)
      ijsonstr = geom.ExportToJson()
      return(geojson.loads(ijsonstr)) # now have a dict
#+END_SRC

#+name: extractshape
#+BEGIN_SRC python
  def extractshape(ifile, layer, feature):
      """returns a Shapely object of feature FEATURE in layer LAYER in file IFILE"""
      import geojson
      import shapely.geometry

      <<extractjson>>

      # get the json
      json = extractjson(ifile, layer, feature)

      # convert it to shapely and return
      return shapely.geometry.shape(json)
#+END_SRC

#+BEGIN_SRC python :tangle extractwkt :shebang "#!/usr/bin/env python"
  <<caution>>

  <<eprint>>

  import argparse
  import os
  import sys

  <<extractgml>>
  <<extractjson>>
  <<extractwkt>>
  <<extractshape>>

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="""extract the well-known text (wkt) of a feature of a layer in a file.  example usage:
      `python extractwkt.py -l Soberanes -f "Heat Perimeter" ~/work/gis/play/IR/20160729_Soberanes_IR/doc.kml\'""")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      parser.add_argument('-t', '--type', choices=['Wkt', 'Json', 'GML', 'Shape'], default='Wkt',
                          help="type of output [Wkt]")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('ifile', type=str, help="file to process")
      args = parser.parse_args();

      # make sure ifile is readable
      if not os.access(args.ifile, os.R_OK):
          eprint("input file '%s' cannot be read" % args.ifile)
          sys.exit(2)

      if args.type == "Wkt":
          print(extractwkt(args.ifile, args.layername, args.featurename))
      elif args.type == "Json":
          print(extractjson(args.ifile, args.layername, args.featurename))
      elif args.type == "GML":
          print(extractgml(args.ifile, args.layername, args.featurename))
      elif args.type == 'Shape':
          print(extractshape(args.ifile, args.layername, args.featurename))

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC


XXX
it would be nice to read direct from a .kmz (zip) file.  but it
doesn't seem like the current gdal/ogr supports that.
#+BEGIN_EXAMPLE
import zipfile
zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
print(zf)
zf.namelist()
doc = zf.open("doc.kml")
data = doc.read()
#+END_EXAMPLE

** difference

#+BEGIN_SRC python :tangle difference :shebang "#!/usr/bin/env python"
  <<caution>>
  <<eprint>>
  <<extractshape>>
  <<GpShape>>

  import argparse
  import shapely

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description=""" compute the set-theoretic difference between layers/features in
      files.  can specify --feature/--layer once, so same in all files.
      or, specify once for each input file.  each successive file is
      subtracted from (what is left over of) the first file.  note that
      you need to separate the file names from the layer/feature by
      using "--" """)
      parser.add_argument('-l', '--layers', type=str, nargs="+", required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--features', type=str, nargs="+", required=True,
                          help="name of desired feature (within layer)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('files', type=str, nargs='*', help="input files")
      args = parser.parse_args()

      """
  validity check input. basically, good if one of the following is true
  - all three the same
  - one one, other two N
  - two one, other N

  which is to say, at most two different counts and, if two, one has to be one.

  """

      lens = { len(args.layers), len(args.features), len(args.files) }

      if (len(lens) != 1 and 1 not in lens) or len(lens) > 2:
          eprint("""wrong number of file/feature/layer arguments: all
          three can appear the same number of times; or two can appear
          the same number of times and at least one must appear one
          time""")
          sys.exit(1)

      if len(lens) > 1:
          h = max(lens)
          if len(args.files) == 1:
              args.files = reduce(lambda x,y: x + args.files, range(h), [])
          if len(args.layers) == 1:
              args.layers = reduce(lambda x,y: x + args.layers, range(h), [])
          if len(args.features) == 1:
              args.features = reduce(lambda x,y: x + args.features,
                                     range(h), [])

      shapes = map(lambda file, layer, feature: extractshape(file, layer, feature),
                   args.files, args.layers, args.features)
      result = reduce(lambda x,y: x.difference(y), shapes)

      gp = GpShape()
      print("print about to add red")
      gp.add(result, fillstyle="solid", fillcolor='"red"')
      print("print about to add blue")
      gp.add(shapes[0], fillstyle="empty", linecolor='"blue"')
      gp.plot()

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

** working code
*** common utility functions

***** eprint: print to stderr

this must be *first* (non-comment, non-blank) line in file.

#+name: eprint
#+BEGIN_SRC python
  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  from __future__ import print_function # for eprint() below
  import sys

  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)
#+END_SRC

***** colorsub

#+name: colorsub
#+BEGIN_SRC python
  def rgbtokml(rgb):
      """convert an rgb to kml's bgr"""

      r = (rgb/(256*256)) % 256
      g = (rgb/256) % 256
      b = rgb % 256
      bgr = (b*256*256)+(g*256)+(r)
      return bgr

  def colorsub(hexvalue, stylefrag):
      """insert an RGB value (really KML's BGR value) into a piece of text"""

      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(hexvalue) is int:
          hvalue = hexvalue
      else:
          hvalue = int(hexvalue, base=16)
      return re.sub("<HEXVALUE>", "{0:x}".format(0x90000000 | rgbtokml(hvalue)),
                    stylefrag)
#+END_SRC

***** fragsub

#+name: fragsub
#+BEGIN_SRC python
  def fragsub(fragid, stylefrag):
      """insert a fragment id into a kml fragment"""

      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(fragid) is int:
          sfrag = str(fragid)
      else:
          sfrag = fragid
      return re.sub("<FRAGID>", sfrag, stylefrag)
#+END_SRC

***** fprolog

#+name: fprolog
#+BEGIN_SRC python
  def fprolog2():
      return fragsub(0, colorsub(color0, stylefrag))

  def fprolog3():
      result = ""
      for i in range(len(colors)):
          result = "{0}{1}".format(result,
                                   fragsub(i+1, colorsub(colors[i], stylefrag)))
      return result

  def fprolog4():
      return fragsub("N", colorsub(colorN, stylefrag))

  def fprolog():
      """return the prolog to a fragment (one perimeter) of a file"""

      import re

      return "{0}\n{1}\n{2}\n{3}".format(re.sub("<DOCNAME>", layername, fprolog1),
                                         fprolog2(), fprolog3(), fprolog4())
#+END_SRC

***** kmlfrags

#+name: kmlfrags
#+BEGIN_SRC python
  def labelit(label):
      """we have N colors and M things to label; determine the correct 
  color for label number LABEL"""

      import math

      return int(math.ceil((1.0*ncolors/nkmls)*label))

  def kmlit(label, kml, fname):
      import re
      import math
      import os.path

      placemarkname = os.path.split(os.path.split(fname)[0])[1]

      if kml == None:
          return ""
      else:
          return re.sub("<POLYGON>", kml,
                        re.sub("<FRAGID>", str(label), 
                               re.sub("<PLACEMARKNAME>", placemarkname, pprolog1))) + ppost


  def kmlfrags():
      """do most of the processing: for each kml file, get the kml bits out
  of it, then generate the correct label for it (the first and last file
  have distinguished labels), and return the concatenation of it all"""

      global nkmls

      kmls = extract_kmls()
      nkmls = len(kmls)
      labels = [0]
      for i in range(1, len(kmls)-1):
          labels = labels + [labelit(i)]
      labels = labels + ["N"]
      result = ""
      # we run the list *backwards* so that newer (more expansive)
      # layers hide under older (more restricted) layers, to show the
      # growth day to day
      for i in list(reversed(range(len(kmls)))):
          kml = kmls[i]
          if kml != None:
              result = result+kmlit(labels[i], kml, kmlfiles[i])
      return result
#+END_SRC

***** file_fragments: string constants used by rest of code

colors can be found [[http://www.tayloredmktg.com/rgb/][here]].

#+name: file_fragments
#+BEGIN_SRC python
  fprolog1 = """<?xml version="1.0" encoding="UTF-8"?>
  <kml xmlns="http://earth.google.com/kml/2.0">
  <Document><name><DOCNAME></name>
  """

  color0 = 0xfcbba1
  # from http://www.personal.psu.edu/cab38/ColorBrewer/ColorBrewer.html
  # or http://colorbrewer2.org/
  # 9-class sequential PuBu
  colors = [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf,
            0x3690c0, 0x0570b0, 0x045a8d, 0x023858]
  ncolors = len(colors)
  colorN = 0xdc0000
  nkmls = 0

  stylefrag="""<Style id="style<FRAGID>">
  <LineStyle id="lineStyle<FRAGID>">
  <color>ff000000</color>
  <width>2</width>
  </LineStyle>
  <PolyStyle id="polyStyle<FRAGID>">
  <color><HEXVALUE></color>
  </PolyStyle>
  </Style>
  """

  pprolog1="""<Placemark><name><PLACEMARKNAME></name>
  <styleUrl>#style<FRAGID></styleUrl>
  <MultiGeometry><POLYGON>"""

  ppost="""</MultiGeometry></Placemark>
  """

  fpost="""</Document>
  </kml>
  """
#+END_SRC

*** awklike

--layername "Soberanes" --featurename "Heat Perimeter"

now, it turns out (see gis.org) that the exact way the IR data is
give, we can forget all about any of the GIS tools, and extract the
desired KML-bits with awk.  then, assuming Google Earth pays attention
to the order in which layers are defined, probably all will be good.

okay, because of the IR doc.kml files' format, we can do all this
without worrying much about GIS APIs, basically, it could be an awk
script.  unfortunately, when a new plane was put into service, the new
file formats didn't work for this.

#+BEGIN_SRC python :tangle awklike :shebang "#!/usr/bin/env python"
  <<caution>>

  import sys

  <<file_fragments>>

  <<colorsub>>
  <<fragsub>>
  <<extract_kmls>>
  <<fprolog>>
  <<kmlfrags>>

  def extract_line(file, trigger, select):
      """extract the first line matching SELECT that appears after the
  line matching TRIGGER"""
      import re
      f = open(file, 'r');
      for t in f:
          if (re.search(trigger, t)):
              for t in f:
                  if (re.search(select, t)):
                      return t;

  def extract_kmls():
      import os
      kmls = []
      for file in kmlfiles:
          kmls = kmls + [extract_line(os.path.expanduser(file), featurename, select)]
      return kmls


  def main(argv):
      import argparse

      global layername, featurename, select, kmlfiles

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="reduce a feature of a layer from a number of KML files to a single KML file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
        # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      layername = args.layername
      featurename = args.featurename
      select = "Polygon"

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

*** parsing as an xml document

*** xml parsers we ended up not using for one reason or other

so, maybe i should break down and use some
[[https://docs.python.org/2/library/xml.html][python xml parser]].  but, which one?

***** [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]]

it [[http://stackoverflow.com/a/1912483/1527747][seems like]] [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]] is the way to parse.

this works for the first set of IR files for the Soberanes fire, but
not for the military-produced files.  possibly i need the full power
of xpath expressions (which i guess ElementTree doesn't provide).

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" :results output verbatim
  import xml.etree.ElementTree as et

  # set up namespace
  # http://stackoverflow.com/a/29021450/1527747
  et.register_namespace("","http://www.opengis.net/kml/2.2")
  ns = { "kml2.2": "http://www.opengis.net/kml/2.2" }

  tree = et.parse(input)
  root = tree.getroot()

  doc = root.find("kml2.2:Document", ns)

  places = doc.findall("kml2.2:Placemark", ns)

  # list comprehensions
  # https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
  hperil = [i for i in places if
            i.find("kml2.2:name", ns).text == "Heat Perimeter"]

  mg = hperil[0].find("kml2.2:MultiGeometry", ns)

  str = et.tostring(mg)
  print len(str)
#+END_SRC

#+RESULTS:
: 89305

***** [[https://github.com/stchris/untangle][untangle]]
but, [[https://github.com/stchris/untangle][untangle]] seems also nice.  so...
#+BEGIN_EXAMPLE
sudo pip install untangle
#+END_EXAMPLE
to install it

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" :results output verbatim
import untangle

kml = untangle.parse(input)

for i in kml.kml.Document:
  print i

#+END_SRC

#+RESULTS:

i'm not sure, though, how to get the raw contents of a subtree.

***** [[https://github.com/martinblech/xmltodict/blob/master/xmltodict.py][xmltodict]]

another simple parser.  allows unparse.

#+BEGIN_SRC python :results output verbatim
import xmltodict

input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" 

xd = xmltodict.parse(open(input))

print len(xd["kml"]["Document"].get('Placemark'))

#+END_SRC

this is nice.  but, really, probably need xpath expression support, in
order to allow user to specify the place(s) in the tree to pull out
the multigeometries.

***** [[https://docs.python.org/3/library/xml.dom.html][xml.dom]]

complicated?

*** xpathusing.py

okay, [[https://pypi.python.org/pypi/lxml/3.6.1][lxml]] works.  nicely.

to figure out the search term, an xml "flattener" is useful, such as
#+BEGIN_EXAMPLE
xml2 < ~/work/gis/play/IR/20160812_c0730_Soberanes_Aircraft3_All/doc.kml | less
#+END_EXAMPLE

a good simple reference for xpath expressions at [[http://www.w3schools.com/xsl/xpath_syntax.asp][w3schools.com]]

#+BEGIN_SRC python :tangle xpathusing :results output verbatim :shebang "#!/usr/bin/env python"
  <<caution>>

  import sys

  <<file_fragments>>

  <<colorsub>>
  <<fragsub>>
  <<fprolog>>
  <<kmlfrags>>

  def extract_kmls():
      import os
      from lxml import etree

      kmls = []
      for file in kmlfiles:
          tree = etree.parse(file)
          extracts = tree.xpath(expr, namespaces=nspace)
          frags = ""
          for extract in extracts:
              frags = frags + etree.tostring(extract)
          kmls = kmls + [frags]
      return kmls


  def main(argv):
      import argparse

      global layername, nspace, expr, kmlfiles

      # namespace
      def_nsabbrev = "kml2.2"
      def_nslong = "http://www.opengis.net/kml/2.2"
      def_ns = { def_nsabbrev : def_nslong }

      def_expr = """
  //kml2.2:MultiGeometry[../kml2.2:name="Heat Perimeter"] |
  //kml2.2:MultiGeometry[../../kml2.2:name="Estimated Perimeter"] |
  //kml2.2:MultiGeometry[../../kml2.2:name="Fire Perimeter"]"""

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="take a number of geometry features from a group of kml files and produce one kml file")
      parser.add_argument('--nsabbrev', type=str, default=def_nsabbrev,
                          help='abbreviation for namespace (default: "{0}")'.format(def_nsabbrev))
      parser.add_argument('--nslong', type=str, default=def_nslong,
                          help='long name for namespace (default: "{0}")'.format(def_nslong))
      parser.add_argument('-e', '--expr', type=str, default=def_expr,
                          help='xpat expression (default is "{0}")'.format(def_expr))
      parser.add_argument('-l', '--layername', type=str, default="Soberanes",
                          help='name of desired layer (output file, default "Soberanes")')

      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      nspace =  {args.nsabbrev: args.nslong}
      layername = args.layername
      expr = args.expr

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)

#+END_SRC

here's an example of how to use:
#+BEGIN_EXAMPLE
python xpathusing.py `ls ~/work/gis/play/IR/20160???*Soberanes*/doc.kml | sort` 2>&1 > y.kml
#+END_EXAMPLE

** my "library"

this just consists of various general purpose routines i want to use
in other applications.

#+BEGIN_SRC python :tangle ggmlib.py
  <<eprint>>
  <<shPolyJson>>
  <<shPolyShape>>
  <<shPoly>>
  <<featuregeometry>>
  <<extractwkt>>
  <<extractgml>>
  <<extractjson>>
  <<extractshape>>

#+END_SRC

** [[http://geoscript.org/][geoscript]]

a way of accessing JTS.  which, if GEOS is solely a downstream of JTS,
maybe closer is better...  related to [[http://www.geotools.org/][GeoTools]].  so, download geotools
(big) and (fink install) maven.  i needed to do
#+BEGIN_EXAMPLE
export JAVA_HOME=`/System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java_home`
#+END_EXAMPLE
to make it work.  then
#+BEGIN_EXAMPLE
C:java>  mvn archetype:generate -DgroupId=org.geotools -DartifactId=tutorial -Dversion=1.0-SNAPSHOT -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart
#+END_EXAMPLE

but, sigh, maybe it requires Java.  which i have, but ...

** playing

#+BEGIN_SRC python :results none :session py
import os, sys
import shPoly

js = {'type': 'Polygon', 'coordinates': [[[1208064.271243039, 614453.958118695], [1208064.271243039, 624154.6783778917], [1219317.1067437078, 624154.6783778917], [1219317.1067437078, 614453.958118695], [1208064.271243039, 614453.958118695]]]}
xs = shPoly.extractjson("x.gml", "Soberanes", "Heat Perimeter")

#+END_SRC

oof.  importing matplotlib takes at least 1 second of user time
#+BEGIN_EXAMPLE
bash greg-minshalls-mbp-2: {1308} ./shPoly.py -l OGRGeoJSON -f "Heat Perimeter" x.json 
(0.01, 0.01, 0.0, 0.0, 1472203897.95) before extractjson
(0.04, 0.02, 0.0, 0.0, 1472203898.0) after extractjson
(0.04, 0.02, 0.0, 0.0, 1472203898.0) before warnings
(0.04, 0.02, 0.0, 0.0, 1472203898.0) before import matplotlib
(1.05, 0.22, 0.08, 0.02, 1472203899.41) after import matplotlib
(1.1, 0.23, 0.08, 0.02, 1472203899.47) before getxy
(1.1, 0.23, 0.08, 0.02, 1472203899.47) before ax.plot
(1.1, 0.23, 0.08, 0.02, 1472203899.47) before getxy
(1.1, 0.23, 0.08, 0.02, 1472203899.47) before ax.plot
#+END_EXAMPLE
from os.times().  (the results are pretty stable: 1 second user; .2
seconds system)

otoh, matplotlib plotting itself is very fast.

** gnuplot?

a couple of packages.  [[http://gnuplot-py.sourceforge.net/][Gnuplot]] (fink: gnuplot-py27) seems nice.  otoh,
it doesn't support what i need "natively", so maybe [[https://github.com/jfindlay/gp.py][gp.py]] will be
better?

#+BEGIN_SRC python :results none
  import gp

  g = gp.GP(term='x11')

  g.write("set xrange [-1.5:4.5]")
  g.write("set yrange [-3:3]")
  g.write("set size ratio -1")

  g.write("a = 1.0/3")
  g.write(" \
  set object 1 polygon from \
      -1, 1 to \
       0, 1 to \
       0, a to \
       1, 1 to \
       1,-1 to \
       0,-a to \
       0,-1 to \
      -1,-1 to \
      -1, 1""")

  g.write("set object 1 fc rgb '#000000' fillstyle solid lw 0")

  g.write("set parametric")
  g.write("set trange [-pi/6:pi/6]")
  g.write("fx(t,r) = r*cos(t)")
  g.write("fy(t,r) = r*sin(t)")

  g.write("plot fx(t,2),fy(t,2) with lines ls 1, \
       fx(t,3),fy(t,3) with lines ls 1, \
       fx(t,4),fy(t,4) with lines ls 1")
#+END_SRC

#+name: GpShape
#+BEGIN_SRC python
  import gp

  class GpShape(gp.GP):
      """plotting Shapely objects using gnuplot.  for information on mouse
  binding you can try launching gnuplot and saying 'show bind'; also,
  see http://stackoverflow.com/a/23346921/1527747

      """

      def __init__(self, term='x11'):
          if term == None and term != "":
              gp.GP.__init__(self)
          else:
              gp.GP.__init__(self, term=term)
          self.reset()
          self.__setdefaults__()

      def reset(self):
          self.objid = 0
          gp.GP.write(self, "reset")
          gp.GP.write(self, "set size ratio -1")
          gp.GP.write(self, "set key outside")
          # https://groups.google.com/forum/#!topic/comp.graphics.apps.gnuplot/uPJ7oGaEC8o
          gp.GP.write(self, "unset border")
          gp.GP.write(self, "unset xtics")
          gp.GP.write(self, "unset ytics")
          self.minx = self.miny = self.maxx = self.maxy = None
          self.reppoint = None    # need a representative point for
                                  # plotting a blank page




      def __setdefaults__(self):
          defs = { 'fillstyle': "empty",
                   'fillcolor': "rgb 0x000000",
                   'transparency': 1.0,
                   'density': 1.0,
                   'border': "off",
                   'linecolor': "rgb 0x000000",
                   'linewidth': 1,
                   'legend': "off",
          }
          self.__defaults__ = defs;

      def setdefaults(self, **kwargs):
          """set one or more defaults for plotting; complex defaults should be
          specified as a single string (e.g., linecolor="rgbcolor
          0x000000").

          i don't want to duplicate all of gnuplot's parameters, since a
          "power user" can always just to g.write("...").  but, some
          things are fairly common.  use getdefaults() to see the
          defaults.

          so, plan is to have defaults from "compile" time, the ability
          to change the defaults (for subsequent calls this session),
          and the ability to specify a different value on each
          invocation of add)

          """
          # from Gnuplot.py's set()
          for (k,v) in kwargs.items():
              try:
                  type = self.defaults[k]
              except:
                  raise NameError("setdefaults: no default {0}".format(k))
              if type(v) != type(self.__defaults__[k]):
                  raise TypeError("key should be of type {0}, but {1} (of type {2}) passed".format(
                      type(self.__defaults__[k], v, type(v))))
              self.__defaults__[k] = v

      def getdefaults(self, *args):
          if (len(args)) == 0:
              return self.__defaults__
          else:
              results = {}
              for k in args.items():
                  try:
                      results.add(self.__defaults__[k])
                  except:
                      raise NameError("getdefaults: no default {0}".format(k))
              return results

      def __stylespec__(self, prefix, defs):
          """from defaults and options passed on call, put together a valid
  style spec

          """

          def ifel(k,v):
              if v == "":
                  return ""
              else:
                  return " {k} {v}".format(k=k,v=v)

          # now we have a complete list of options, turn them into a
          # style list.
          results = prefix        # first part of command line
          # ternary operator: http://stackoverflow.com/a/394814/1527747

          # fillstyle
          if defs['fillstyle'] in [None, "empty"]:
              results += " fillstyle empty"
          else:
              results += " fillstyle"
              if defs['transparency'] != 1:
                  # so, <density> is used to encode the transparency.
                  results += " transparent {f} {d}".format(f=defs['fillstyle'],
                                                           d=defs['transparency'])
              else:
                  results += " {f} {d}".format(f=defs['fillstyle'],
                                               d=defs['density'])
                  results += ifel('fillcolor', defs['fillcolor'])

          # linestyle (only if a border)
          if {defs['linecolor'], defs['linewidth']} != set([""]):
              # something isn't blank
              results += "\n{0} fillstyle".format(prefix)
              results += " border"
              results += ifel('linecolor', defs['linecolor'])
              results += ifel('linewidth', defs['linewidth'])
          return results


      def __minmax__(self, coords):
          """keep our minimums and maximums up to date"""
          # http://stackoverflow.com/a/26310202/1527747
          cminx = min([pair[0] for pair in coords])
          cminy = min([pair[1] for pair in coords])
          cmaxx = max([pair[0] for pair in coords])
          cmaxy = max([pair[1] for pair in coords])
          if self.minx == None or self.minx > cminx:
              self.minx = cminx
          if self.miny == None or self.miny > cminy:
              self.miny = cminy
          if self.maxx == None or self.maxx < cmaxx:
              self.maxx = cmaxx
          if self.maxy == None or self.maxy < cmaxy:
              self.maxy = cmaxy

      def __rewrite__(self, pairs, btw, inter):
          """from a sequence of PAIRS, pull them out and separate them with
      BTW, and the separate successive pairs with INTER."""
          def doit(x,y):
              """reduce routine.  need to distinguish first from successive calls.
              """
              if type(x) == tuple:
                  return "{0}{1}{2}{3}{4}{5}{6}".format(x[0], btw, x[1],
                                                        inter, y[0], btw, y[1])
              elif type(x) == str:
                  return "{0}{1}{2}{3}{4}".format(x, inter, y[0], btw, y[1])
              else:
                  raise TypeError("internal error: type s/b tuple or str")
          return reduce(doit, pairs)

      def __add__(self, shape, defs):
          """do the work to actually add shapely SHAPE geometries to the plot"""

          self.objid += 1         # make sure this happens
          if shape.type in ['MultiPoint', 'MultiLine', 
                            'MultiPolygon', 'GeometryCollection']:
              self.objid -= 1     # (but we don't want it here)
              for geom in shape.geoms:
                  self.__add__(geom, defs)  # recurse for each sub-geometry
          #elif shape.type == 'Point':   XXX
          #    pass
          #elif shape.type == 'Line':
          #    pass
          elif shape.type == 'Polygon': # gp.GP.write(self, ...):
              if self.reppoint == None:
                  self.reppoint = shape.exterior.coords[0]
              self.__minmax__(shape.exterior.coords)
              outstr = self.__rewrite__(shape.exterior.coords, ", ", " to ")
              # gp.py's write() call sleeps here (for O(size of string)
              # with the comment "gnuplot actions are nonblocking" so,
              # we short cut that here when writing out (potentialy)
              # thousands of points
              self.stdin.write("set object {i} polygon from {s}\n".format(i=self.objid,
                                                                          s=outstr))
              # set the style for that object
              prefix = "set object {i}".format(i=self.objid) # prefix to use
              styles = self.__stylespec__(prefix, defs)
              gp.GP.write(self, styles)
          else:
              # http://stackoverflow.com/a/24065533/1527747
              raise TypeError("type is '{0}', but we only support 'MultiPolygon' and 'Polygon'".format(shape.type))

      def __mergedefaults__(self, **kwargs):
          defs = self.__defaults__
          for (k,v) in kwargs.items():
              try:
                  defs[k] = v
              except:
                  raise NameError("unknown option {0}; use getdefaults() for list".format(k))
          return defs

      def add(self, shape, **kwargs):
          """plot the shapely SHAPE object"""
          defs = self.__mergedefaults__(**kwargs)
          self.__add__(shape, defs)


      def plot(self, **kwargs):
          defs = self.__mergedefaults__(**kwargs)

          if defs['legend'] != None and defs['legend'] != "":
              gp.GP.write(self, "set key {0}".format(defs['legend']))

          gp.GP.write(self, "set xrange [{x}:{X}]".format(x=self.minx, X=self.maxx))
          gp.GP.write(self, "set yrange [{y}:{Y}]".format(y=self.miny, Y=self.maxy))


          # "How do I produce blank output page?"
          # http://gnuplot.info/faq/faq.html#x1-760006.9
          gp.GP.write(self, "plot [][] {0}".format(self.reppoint))

          # a problem is that when this process terminates, the plot
          # window tends to disappear.  the following, in the case of
          # running under gp.py under python, leaves the window up (and
          # still tracking mouse movements).
          gp.GP.write(self, "\n pause mouse close") # leave window running
          gp.GP.write(self, "\n exit")              # and, exit
          # and, wait for window to close
          gp.GP.read(self)
#+END_SRC
