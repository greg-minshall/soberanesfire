* using python for gis things
** uninteresting org-mode setup, etc.

#+property: header-args :noweb yes

** intro

lots of code in this file hasn't really been developed.
extractwkt.py, awklike.py, and xpathusing.py are function (and the
last is what we are currently using).

[[http://stackoverflow.com/questions/101268/hidden-features-of-python][hidden features of python exposed!!]]

*** python classes

here are some references to Python classes
- [[https://hplgit.github.io/primer.html/doc/pub/class/._class-readable005.html][good example]] of implementing a class, and also discusses some of the
  __MAGIC__.
- [[http://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch-part-2][article]] on multiple dispatch
- Guido [[https://www.artima.com/weblogs/viewpost.jsp?thread=101605][article]] on multi-methods
- [[https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators][wiki entry on language features]] contains some info on decorators
  (used in multi-methods)

** caution

#+name: caution
#+BEGIN_SRC python
"""WARNING: THIS FILE IS PRODUCED BY python.org.  ANY CHANGES MADE HERE
WILL LIKELY BE LOST.  DO NOT MODIFY THIS FILE; RATHER, MODIFY python.org."""
#+END_SRC

** using [[https://pypi.python.org/pypi/Shapely][shapely]]

the [[toblerity.org/shapely/manual.html][manual]] looks promising.  shapely.wkt.loads(), shapely.wkt.dumps()
are what we need.

use ogrinfo to get wkt.  somehow slice it so it just includes the heat
perimeter.  then, read those into shapely:

#+BEGIN_SRC python :results output
from shapely import wkt

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

x1 = wkt.loads(f1.read())
x2 = wkt.loads(f2.read())

y2 = x2.difference(x1)
print y2
#+END_SRC

then, export it somehow in kml format.

[[http://deparkes.co.uk/2015/03/11/how-to-plot-polygons-in-python/][viewing polygons in python]]

#+BEGIN_SRC python :results output
import shapely
import shapely.geometry

a = shapely.geometry.Point(1, 1).buffer(1.5)
b = shapely.geometry.Point(2,2).buffer(1.5)
c = a.difference(b)
print c
#+END_SRC


#+name: shPolyJson
#+BEGIN_SRC python
  def shPolyJson(ijson, imgfile=None, imgextent=None):
      """plot the *exterior*** of a geojson polygon (using matplotlib)"""

      # from https://github.com/matplotlib/matplotlib/issues/5836
      import warnings;
      with warnings.catch_warnings():
          warnings.simplefilter("ignore");
          from matplotlib import pyplot
      import sys

      def getxy(*tuples):
          """return x,y from a pair (x,y) or triple (x,y,z)"""
          if len(tuples[0]) == 2:
              (x,y) = zip(*tuples)
          elif len(tuples[0]) == 3:
              (x,y,z) = zip(*tuples)
          else:
              raise ValueError("should have been a pair or triple, but was an {0}-tuple".format(len(tuples[0])))
          return (x,y)

      fig = pyplot.figure(1, figsize=(5,5), dpi=90)
      # for '111': http://stackoverflow.com/a/6981055/1527747
      # for 'aspect=1.0': http://stackoverflow.com/q/7965743/1527747
      ax = fig.add_subplot(111, aspect=1.0)
      if ijson['type'] == 'MultiPolygon':
          for pgon in range(len(ijson['coordinates'])):
              for lring in range(len(ijson['coordinates'][pgon])):
                  # zip(*zip): http://stackoverflow.com/q/2233204/1527747 and
                  # https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
                  # http://stackoverflow.com/a/2511319/1527747 ("it's (apply)")
                  (x,y) = getxy(*ijson['coordinates'][pgon][lring])
                  ignore = ax.plot(x, y, color='#000000', alpha=0.7,
                                   linewidth=1, solid_capstyle='round', zorder=2)
      elif ijson['type'] == 'Polygon':
          for lring in range(len(ijson['coordinates'])):
              # zip(*zip): http://stackoverflow.com/q/2233204/1527747 and
              # https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
              # http://stackoverflow.com/a/2511319/1527747 ("it's (apply)")
              (x,y) = getxy(*ijson['coordinates'][lring])
              ignore = ax.plot(x, y, color='#000000', alpha=0.7,
                               linewidth=1, solid_capstyle='round', zorder=2)
      else:
          # http://stackoverflow.com/a/24065533/1527747
          raise TypeError("type is '{0}', but we only support 'MultiPolygon' and 'Polygon'".format(ijson['type']))

      if imgfile:
          # http://stackoverflow.com/q/32652428/1527747
          implot = subplot1.imshow(pyplot.imread(r'test.png'), interpolation='nearest',                          alpha=1.0, extent=imgextent)

      ignore = ax.set_title('Polygon')
      pyplot.show()
#+END_SRC

#+name: gpShPolyShape
#+BEGIN_SRC python
  <<GpShape>>
  def shPolyShape(shape, device=None):
      """prints the *EXTERIOR* of SHAPE)""" # XXX to interior cutouts

      gp = GpShape(device)
      gp.add(shape)
      gp.plot()

#+END_SRC

#+name: gpShPoly
#+BEGIN_SRC python :session py  :tangle gpshpoly :results none :shebang "#!/usr/bin/env python"
  import os

  <<extractshape>>
  <<GpShape>>

  def main(argv):
      import os, sys
      import argparse

      cmd = argv[0]
      parser = argparse.ArgumentParser(description=
                                       "plot a feature of a layer from an ogr-readable file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      parser.add_argument('--device', type=str, default=None,
                          help='device on which to plot (gnuplot "set terminal")')
      parser.add_argument('--output', type=str, default=None,
                          help="name of output file (for device=png, etc.)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('filename', type=str, nargs=1)
      args = parser.parse_args();

      gp = GpShape(args.device)
      if (args.output):
          gp.write('set output "{0}"'.format(args.output))
      shape = extractshape(args.filename[0], args.layername, args.featurename)

      gp.add(shape)
      gp.plot()

  # file = "/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml"
  # layer = "Soberanes"
  # feature = "Heat Perimeter"
  # shPoly(file, layer, feature)

  if __name__ == "__main__":
      import sys
      main(sys.argv)
#+END_SRC

#+name: ppShPoly
#+BEGIN_SRC python :session py  :tangle ppshpoly :results none :shebang "#!/usr/bin/env python"
  import os

  <<extractshape>>
  <<PpShape>>

  def main(argv):
      import os, sys
      import argparse

      cmd = argv[0]
      parser = argparse.ArgumentParser(description=
                                       "plot a feature of a layer from an ogr-readable file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('filename', type=str, nargs=1)
      args = parser.parse_args();

      pp = PpShape()
      shape = extractshape(args.filename[0], args.layername, args.featurename)

      pp.add(shape)
      pp.plot()

  # file = "/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml"
  # layer = "Soberanes"
  # feature = "Heat Perimeter"
  # shPoly(file, layer, feature)

  if __name__ == "__main__":
      import sys
      main(sys.argv)
#+END_SRC

to get an arbitrary file/layer/feature into shapely, import FILE via
gdal/ogr, convert LAYER/FEATURE to WKT, then loads() that WKT.

#+BEGIN_SRC python :results output verbatim :session *py*
  import shapely.wkt

  <<extractwkt>>

  wkt = extractwkt("/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml",
      "Soberanes", "Heat Perimeter")

  sh = shapely.wkt.loads(wkt)
  for geom in sh.geoms:
      print(i.geom_type)
#+END_SRC

** using [[https://github.com/Toblerity/Fiona][fiona]]

[[http://www.macwright.org/2012/10/31/gis-with-python-shapely-fiona.html][here]] is a post on fiona.  it seems like fiona gives you a nicer
interface to the attributes than calling ogr directly.

sadly, fiona doesn't deal with the range of filetypes that ogr does,
in particular, it doesn't deal with kml.  but, we can import with
osgeo/ogr, then convert to Json, then, hopefully, feed that to fiona.

in fact, we don't need fiona at all, just (safely) eval the json.
(too bad fiona doesn't have an "import from string" function; i'd be
happier with that.)

#+BEGIN_SRC python :session *py* :results none
  import ast;                     # for ast.literal_eval
  <<featuregeometry>>

  file = "/Users/minshall/work/gis/play/IR/20160724_Soberanes_IR/doc.kml"
  layer = "Soberanes"
  feature = "Heat Perimeter"

  geom = featuregeometry(file, layer, feature)
  # we could use plain eval(), but this is safer
  json = ast.literal_eval(geom.ExportToJson())

#+END_SRC

** using osgeo

[[https://pcjericks.github.io/py-gdalogr-cookbook/geometry.html][nice cookbook]]

#+BEGIN_SRC python :results output
  from osgeo import ogr

  wkt = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r").read()
  pgons = ogr.CreateGeometryFromWkt(wkt)

  kml = pgons.ExportToKML()
  print kml

#+END_SRC

** total flow?

read kml in osgeo, export to wkt1, import wkt1 to shapely, do
differences, export difference to wkt2, read wkt2 in osgeo, export to
kml.

*** extract-geom

so, 1 utility that extracts Heat Perimeter from a kml file, producing
a kml-geom file (to stdout)

*** diff-geom

1 utility that takes two kml-geom files, subtracts the second from the
first, writes the result as a kml-geom file (to stdout)

then, standard gump to glue the resulting files together to produce
the difference file.

#+BEGIN_SRC python :results output
from shapely import wkt
from osgeo import ogr

f1 = open("20160806_Soberanes_IR_heat_perimeter.wkt", "r")
f2 = open("20160807_Soberanes_IR_heat_perimeter.wkt", "r")

pgons1 = ogr.CreateGeometryFromWkt(f1.read())
pgons2 = ogr.CreateGeometryFromWkt(f2.read())

kml = pgons1.ExportToKML()
print kml

#+END_SRC

#+RESULTS:
: None

** featuregeometry

#+name: featuregeometry
#+BEGIN_SRC python :results none
  def featuregeometry(filename, layername, featurename):
        """extract the geometry of a given feature in a given layer in a given
  file"""
        import osgeo
        from osgeo import gdal
        from osgeo import ogr

        file = ogr.Open(filename)
        # print("this is %s data" % file.GetDriver().GetName())
        # print("there is/are %d layer(s)" % file.GetLayerCount())
        l = file.GetLayerByName(layername) # type(l) == OGRLayerH
        if l is None:
            raise NameError("layer '%s' is not found in file '%s'" % (layername, filename))
        l.ResetReading()
        # find the right feature
        found = False
        for featid in range(l.GetFeatureCount()):
              feature = l.GetFeature(featid); # type(feature) == OGRFeatureH
              fieldid = feature.GetFieldIndex("Name");
              name = feature.GetFieldAsString(fieldid);
              if (name == featurename):
                    found = True
                    break;
        if not found:
              raise NameError("feature name '%s' not found in layer '%s' in file '%s'" %
                     (featurename, layername, filename))
        # okay, we found the right feature.  now, find the polygon, maybe
        # a multigeometry
        geometry = feature.GetGeometryRef().Clone()
        return geometry
#+END_SRC

** extractwkt.py

this prints the wkt of a layer/feature of a kml file

#+name: extractwkt
#+BEGIN_SRC python
  <<featuregeometry>>

  def extractwkt(ifile, layername, featurename):
      """returns the WKT of the geometry of feature FEATURENAME in layer
      LAYERNAME in file FILE

      """
      # get polygons from this file
      pgons = featuregeometry(ifile, layername, featurename)
      # print(pgons)
      return(pgons.ExportToWkt())
#+END_SRC

#+RESULTS: extractwkt

#+name: extractgml
#+BEGIN_SRC python
  def extractgml(ifile, layername, featurename):
      """returns the GML of the geometry of feature FEATURENAME in layer
  LAYERNAME in file FILE

      """

      <<featuregeometry>>

      # get geometry from this file
      geom = featuregeometry(ifile, layername, featurename)
      return geom.ExportToGML()
#+END_SRC

#+name: extractjson
#+BEGIN_SRC python
  def extractjson(ifile, layername, featurename):
      """returns the WKT of the geometry of feature FEATURENAME in layer
      LAYERNAME in file FILE

      """
      import geojson

      <<featuregeometry>>

      # get polygons from this file
      geom = featuregeometry(ifile, layername, featurename)
      # print(geom)
      ijsonstr = geom.ExportToJson()
      return(geojson.loads(ijsonstr)) # now have a dict
#+END_SRC

#+name: extractshape
#+BEGIN_SRC python
  def extractshape(ifile, layer, feature):
      """returns a Shapely object of feature FEATURE in layer LAYER in file IFILE"""
      import geojson
      import shapely.geometry

      <<extractjson>>

      # get the json
      json = extractjson(ifile, layer, feature)

      # convert it to shapely and return
      return shapely.geometry.shape(json)
#+END_SRC

#+BEGIN_SRC python :tangle extractwkt :shebang "#!/usr/bin/env python"
  <<caution>>

  <<eprint>>

  import argparse
  import os
  import sys

  <<extractgml>>
  <<extractjson>>
  <<extractwkt>>
  <<extractshape>>

  # XXX
  # it would be nice to read direct from a .kmz (zip) file.  but it
  # doesn't seem like the current gdal/ogr supports that.
  # import zipfile
  # zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
  # print(zf)
  # zf.namelist()
  # ndoc = zf.open("doc.kml")
  # data = doc.read()
  # XXX

  # get layer name: Soberanes
  # get feature name: Heat Perimeter

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description="""extract the well-known text (wkt) of a feature of a layer in a file.  example usage:
      `python extractwkt.py -l Soberanes -f "Heat Perimeter" ~/work/gis/play/IR/20160729_Soberanes_IR/doc.kml\'""")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      parser.add_argument('-t', '--type', choices=['Wkt', 'Json', 'GML', 'Shape'], default='Wkt',
                          help="type of output [Wkt]")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('ifile', type=str, help="file to process")
      args = parser.parse_args();

      # make sure ifile is readable
      if not os.access(args.ifile, os.R_OK):
          eprint("input file '%s' cannot be read" % args.ifile)
          sys.exit(2)

      if args.type == "Wkt":
          print(extractwkt(args.ifile, args.layername, args.featurename))
      elif args.type == "Json":
          print(extractjson(args.ifile, args.layername, args.featurename))
      elif args.type == "GML":
          print(extractgml(args.ifile, args.layername, args.featurename))
      elif args.type == 'Shape':
          print(extractshape(args.ifile, args.layername, args.featurename))

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC


XXX
it would be nice to read direct from a .kmz (zip) file.  but it
doesn't seem like the current gdal/ogr supports that.
#+BEGIN_EXAMPLE
import zipfile
zf = zipfile.ZipFile("20160729_Soberanes_IR.kmz", "r")
print(zf)
zf.namelist()
doc = zf.open("doc.kml")
data = doc.read()
#+END_EXAMPLE

** difference

#+BEGIN_SRC python :tangle difference :shebang "#!/usr/bin/env python"
  <<caution>>
  <<eprint>>
  <<extractshape>>
  <<GpShape>>

  import argparse
  import shapely

  def main(argv):
      cmd = argv[0]
      parser = argparse.ArgumentParser(description=""" compute the set-theoretic difference between layers/features in
      files.  can specify --feature/--layer once, so same in all files.
      or, specify once for each input file.  each successive file is
      subtracted from (what is left over of) the first file.  note that
      you need to separate the file names from the layer/feature by
      using "--" """)
      parser.add_argument('-l', '--layers', type=str, nargs="+", required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--features', type=str, nargs="+", required=True,
                          help="name of desired feature (within layer)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('files', type=str, nargs='*', help="input files")
      args = parser.parse_args()

      """
  validity check input. basically, good if one of the following is true
  - all three the same
  - one one, other two N
  - two one, other N

  which is to say, at most two different counts and, if two, one has to be one.

  """

      lens = { len(args.layers), len(args.features), len(args.files) }

      if (len(lens) != 1 and 1 not in lens) or len(lens) > 2:
          eprint("""wrong number of file/feature/layer arguments: all
          three can appear the same number of times; or two can appear
          the same number of times and at least one must appear one
          time""")
          sys.exit(1)

      if len(lens) > 1:
          h = max(lens)
          if len(args.files) == 1:
              args.files = reduce(lambda x,y: x + args.files, range(h), [])
          if len(args.layers) == 1:
              args.layers = reduce(lambda x,y: x + args.layers, range(h), [])
          if len(args.features) == 1:
              args.features = reduce(lambda x,y: x + args.features,
                                     range(h), [])

      shapes = map(lambda file, layer, feature: extractshape(file, layer, feature),
                   args.files, args.layers, args.features)
      result = reduce(lambda x,y: x.difference(y), shapes)

      gp = GpShape()
      print("print about to add red")
      gp.add(result, fillstyle="solid", fillcolor='"red"')
      print("print about to add blue")
      gp.add(shapes[0], fillstyle="empty", linecolor='"blue"')
      gp.plot()

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

** working code
*** common utility functions

***** eprint: print to stderr

this must be *first* (non-comment, non-blank) line in file.

#+name: eprint
#+BEGIN_SRC python
  # from [[http://stackoverflow.com/a/14981125][stack exchange]]
  from __future__ import print_function # for eprint() below
  import sys

  def eprint(*args, **kwargs):
      print(*args, file=sys.stderr, **kwargs)
#+END_SRC

***** colorsub

#+name: colorsub
#+BEGIN_SRC python
  def rgbtokml(rgb):
      """convert an rgb to kml's bgr"""

      r = (rgb/(256*256)) % 256
      g = (rgb/256) % 256
      b = rgb % 256
      bgr = (b*256*256)+(g*256)+(r)
      return bgr

  def colorsub(hexvalue, stylefrag):
      """insert an RGB value (really KML's BGR value) into a piece of text"""

      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(hexvalue) is int:
          hvalue = hexvalue
      else:
          hvalue = int(hexvalue, base=16)
      return re.sub("<HEXVALUE>", "{0:x}".format(0x90000000 | rgbtokml(hvalue)),
                    stylefrag)
#+END_SRC

***** fragsub

#+name: fragsub
#+BEGIN_SRC python
  def fragsub(fragid, stylefrag):
      """insert a fragment id into a kml fragment"""

      import re
      # http://stackoverflow.com/a/402704/1527747
      if type(fragid) is int:
          sfrag = str(fragid)
      else:
          sfrag = fragid
      return re.sub("<FRAGID>", sfrag, stylefrag)
#+END_SRC

***** fprolog

#+name: fprolog
#+BEGIN_SRC python
  def fprolog2():
      return fragsub(0, colorsub(color0, stylefrag))

  def fprolog3():
      result = ""
      for i in range(len(colors)):
          result = "{0}{1}".format(result,
                                   fragsub(i+1, colorsub(colors[i], stylefrag)))
      return result

  def fprolog4():
      return fragsub("N", colorsub(colorN, stylefrag))

  def fprolog():
      """return the prolog to a fragment (one perimeter) of a file"""

      import re

      return "{0}\n{1}\n{2}\n{3}".format(re.sub("<DOCNAME>", layername, fprolog1),
                                         fprolog2(), fprolog3(), fprolog4())
#+END_SRC

***** kmlfrags

#+name: kmlfrags
#+BEGIN_SRC python
  def labelit(label):
      """we have N colors and M things to label; determine the correct 
  color for label number LABEL"""

      import math

      return int(math.ceil((1.0*ncolors/nkmls)*label))

  def kmlit(label, kml, fname):
      import re
      import math
      import os.path

      placemarkname = os.path.split(os.path.split(fname)[0])[1]

      if kml == None:
          return ""
      else:
          return re.sub("<POLYGON>", kml,
                        re.sub("<FRAGID>", str(label), 
                               re.sub("<PLACEMARKNAME>", placemarkname, pprolog1))) + ppost


  def kmlfrags():
      """do most of the processing: for each kml file, get the kml bits out
  of it, then generate the correct label for it (the first and last file
  have distinguished labels), and return the concatenation of it all"""

      global nkmls

      kmls = extract_kmls()
      nkmls = len(kmls)
      labels = [0]
      for i in range(1, len(kmls)-1):
          labels = labels + [labelit(i)]
      labels = labels + ["N"]
      result = ""
      # we run the list *backwards* so that newer (more expansive)
      # layers hide under older (more restricted) layers, to show the
      # growth day to day
      for i in list(reversed(range(len(kmls)))):
          kml = kmls[i]
          if kml != None:
              result = result+kmlit(labels[i], kml, kmlfiles[i])
      return result
#+END_SRC

***** file_fragments: string constants used by rest of code

colors can be found [[http://www.tayloredmktg.com/rgb/][here]].

#+name: file_fragments
#+BEGIN_SRC python
  fprolog1 = """<?xml version="1.0" encoding="UTF-8"?>
  <kml xmlns="http://earth.google.com/kml/2.0">
  <Document><name><DOCNAME></name>
  """

  color0 = 0xfcbba1
  # from http://www.personal.psu.edu/cab38/ColorBrewer/ColorBrewer.html
  # or http://colorbrewer2.org/
  # 9-class sequential PuBu
  colors = [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf,
            0x3690c0, 0x0570b0, 0x045a8d, 0x023858]
  ncolors = len(colors)
  colorN = 0xdc0000
  nkmls = 0

  stylefrag="""<Style id="style<FRAGID>">
  <LineStyle id="lineStyle<FRAGID>">
  <color>ff000000</color>
  <width>2</width>
  </LineStyle>
  <PolyStyle id="polyStyle<FRAGID>">
  <color><HEXVALUE></color>
  </PolyStyle>
  </Style>
  """

  pprolog1="""<Placemark><name><PLACEMARKNAME></name>
  <styleUrl>#style<FRAGID></styleUrl>
  <MultiGeometry><POLYGON>"""

  ppost="""</MultiGeometry></Placemark>
  """

  fpost="""</Document>
  </kml>
  """
#+END_SRC

*** awklike

--layername "Soberanes" --featurename "Heat Perimeter"

now, it turns out (see gis.org) that the exact way the IR data is
give, we can forget all about any of the GIS tools, and extract the
desired KML-bits with awk.  then, assuming Google Earth pays attention
to the order in which layers are defined, probably all will be good.

okay, because of the IR doc.kml files' format, we can do all this
without worrying much about GIS APIs, basically, it could be an awk
script.  unfortunately, when a new plane was put into service, the new
file formats didn't work for this.

#+BEGIN_SRC python :tangle awklike :shebang "#!/usr/bin/env python"
  <<caution>>

  import sys

  <<file_fragments>>

  <<colorsub>>
  <<fragsub>>
  <<extract_kmls>>
  <<fprolog>>
  <<kmlfrags>>

  def extract_line(file, trigger, select):
      """extract the first line matching SELECT that appears after the
  line matching TRIGGER"""
      import re
      f = open(file, 'r');
      for t in f:
          if (re.search(trigger, t)):
              for t in f:
                  if (re.search(select, t)):
                      return t;

  def extract_kmls():
      import os
      kmls = []
      for file in kmlfiles:
          kmls = kmls + [extract_line(os.path.expanduser(file), featurename, select)]
      return kmls


  def main(argv):
      import argparse

      global layername, featurename, select, kmlfiles

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="reduce a feature of a layer from a number of KML files to a single KML file")
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
        # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      layername = args.layername
      featurename = args.featurename
      select = "Polygon"

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)
#+END_SRC

*** parsing as an xml document

*** xml parsers we ended up not using for one reason or other

so, maybe i should break down and use some
[[https://docs.python.org/2/library/xml.html][python xml parser]].  but, which one?

***** [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]]

it [[http://stackoverflow.com/a/1912483/1527747][seems like]] [[https://docs.python.org/2.7/library/xml.etree.elementtree.html][Element Tree]] is the way to parse.

this works for the first set of IR files for the Soberanes fire, but
not for the military-produced files.  possibly i need the full power
of xpath expressions (which i guess ElementTree doesn't provide).

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" :results output verbatim
  import xml.etree.ElementTree as et

  # set up namespace
  # http://stackoverflow.com/a/29021450/1527747
  et.register_namespace("","http://www.opengis.net/kml/2.2")
  ns = { "kml2.2": "http://www.opengis.net/kml/2.2" }

  tree = et.parse(input)
  root = tree.getroot()

  doc = root.find("kml2.2:Document", ns)

  places = doc.findall("kml2.2:Placemark", ns)

  # list comprehensions
  # https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
  hperil = [i for i in places if
            i.find("kml2.2:name", ns).text == "Heat Perimeter"]

  mg = hperil[0].find("kml2.2:MultiGeometry", ns)

  str = et.tostring(mg)
  print len(str)
#+END_SRC

#+RESULTS:
: 89305

***** [[https://github.com/stchris/untangle][untangle]]
but, [[https://github.com/stchris/untangle][untangle]] seems also nice.  so...
#+BEGIN_EXAMPLE
sudo pip install untangle
#+END_EXAMPLE
to install it

#+BEGIN_SRC python :var input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" :results output verbatim
import untangle

kml = untangle.parse(input)

for i in kml.kml.Document:
  print i

#+END_SRC

#+RESULTS:

i'm not sure, though, how to get the raw contents of a subtree.

***** [[https://github.com/martinblech/xmltodict/blob/master/xmltodict.py][xmltodict]]

another simple parser.  allows unparse.

#+BEGIN_SRC python :results output verbatim
import xmltodict

input="/Users/minshall/work/gis/play/IR/20160729_Soberanes_IR/doc.kml" 

xd = xmltodict.parse(open(input))

print len(xd["kml"]["Document"].get('Placemark'))

#+END_SRC

this is nice.  but, really, probably need xpath expression support, in
order to allow user to specify the place(s) in the tree to pull out
the multigeometries.

***** [[https://docs.python.org/3/library/xml.dom.html][xml.dom]]

complicated?

*** xpathusing.py

okay, [[https://pypi.python.org/pypi/lxml/3.6.1][lxml]] works.  nicely.

to figure out the search term, an xml "flattener" is useful, such as
#+BEGIN_EXAMPLE
xml2 < ~/work/gis/play/IR/20160812_c0730_Soberanes_Aircraft3_All/doc.kml | less
#+END_EXAMPLE

a good simple reference for xpath expressions at [[http://www.w3schools.com/xsl/xpath_syntax.asp][w3schools.com]]

#+BEGIN_SRC python :tangle xpathusing :results output verbatim :shebang "#!/usr/bin/env python"
  <<caution>>

  import sys

  <<file_fragments>>

  <<colorsub>>
  <<fragsub>>
  <<fprolog>>
  <<kmlfrags>>

  def extract_kmls():
      import os
      from lxml import etree

      kmls = []
      for file in kmlfiles:
          tree = etree.parse(file)
          extracts = tree.xpath(expr, namespaces=nspace)
          frags = ""
          for extract in extracts:
              frags = frags + etree.tostring(extract)
          kmls = kmls + [frags]
      return kmls


  def main(argv):
      import argparse

      global layername, nspace, expr, kmlfiles

      # namespace
      def_nsabbrev = "kml2.2"
      def_nslong = "http://www.opengis.net/kml/2.2"
      def_ns = { def_nsabbrev : def_nslong }

      def_expr = """
  //kml2.2:MultiGeometry[../kml2.2:name="Heat Perimeter"] |
  //kml2.2:MultiGeometry[../../kml2.2:name="Estimated Perimeter"] |
  //kml2.2:MultiGeometry[../../kml2.2:name="Fire Perimeter"]"""

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="take a number of geometry features from a group of kml files and produce one kml file")
      parser.add_argument('--nsabbrev', type=str, default=def_nsabbrev,
                          help='abbreviation for namespace (default: "{0}")'.format(def_nsabbrev))
      parser.add_argument('--nslong', type=str, default=def_nslong,
                          help='long name for namespace (default: "{0}")'.format(def_nslong))
      parser.add_argument('-e', '--expr', type=str, default=def_expr,
                          help='xpat expression (default is "{0}")'.format(def_expr))
      parser.add_argument('-l', '--layername', type=str, default="Soberanes",
                          help='name of desired layer (output file, default "Soberanes")')

      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('kmlfiles', type=str, nargs="+")
      args = parser.parse_args();
      kmlfiles = args.kmlfiles
      nspace =  {args.nsabbrev: args.nslong}
      layername = args.layername
      expr = args.expr

      print("{0}{1}{2}".format(fprolog(), kmlfrags(), fpost))

  if __name__ == "__main__":
      main(sys.argv)

#+END_SRC

here's an example of how to use:
#+BEGIN_EXAMPLE
python xpathusing.py `ls ~/work/gis/play/IR/20160???*Soberanes*/doc.kml | sort` 2>&1 > y.kml
#+END_EXAMPLE

** my "library"

this just consists of various general purpose routines i want to use
in other applications.

#+BEGIN_SRC python :tangle ~/usr/lib/python/ggmlib.py
  <<GpShape>>
  <<eprint>>
  <<shPolyJson>>
  <<shPolyShape>>
  <<shPoly>>
  <<deg2xy>>
  <<deg2url>>
  <<featuregeometry>>
  <<extractwkt>>
  <<extractgml>>
  <<extractjson>>
  <<extractshape>>

#+END_SRC

** [[http://geoscript.org/][geoscript]]

a way of accessing JTS.  which, if GEOS is solely a downstream of JTS,
maybe closer is better...  related to [[http://www.geotools.org/][GeoTools]].  so, download geotools
(big) and (fink install) maven.  i needed to do
#+BEGIN_EXAMPLE
export JAVA_HOME=`/System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java_home`
#+END_EXAMPLE
to make it work.  then
#+BEGIN_EXAMPLE
C:java>  mvn archetype:generate -DgroupId=org.geotools -DartifactId=tutorial -Dversion=1.0-SNAPSHOT -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart
#+END_EXAMPLE

but, sigh, maybe it requires Java.  which i have, but ...

** playing

#+BEGIN_SRC python :results none :session py
import os, sys
import shPoly

js = {'type': 'Polygon', 'coordinates': [[[1208064.271243039, 614453.958118695], [1208064.271243039, 624154.6783778917], [1219317.1067437078, 624154.6783778917], [1219317.1067437078, 614453.958118695], [1208064.271243039, 614453.958118695]]]}
xs = shPoly.extractjson("x.gml", "Soberanes", "Heat Perimeter")

#+END_SRC

oof.  importing matplotlib takes at least 1 second of user time
#+BEGIN_EXAMPLE
bash greg-minshalls-mbp-2: {1308} ./shPoly.py -l OGRGeoJSON -f "Heat Perimeter" x.json 
(0.01, 0.01, 0.0, 0.0, 1472203897.95) before extractjson
(0.04, 0.02, 0.0, 0.0, 1472203898.0) after extractjson
(0.04, 0.02, 0.0, 0.0, 1472203898.0) before warnings
(0.04, 0.02, 0.0, 0.0, 1472203898.0) before import matplotlib
(1.05, 0.22, 0.08, 0.02, 1472203899.41) after import matplotlib
(1.1, 0.23, 0.08, 0.02, 1472203899.47) before getxy
(1.1, 0.23, 0.08, 0.02, 1472203899.47) before ax.plot
(1.1, 0.23, 0.08, 0.02, 1472203899.47) before getxy
(1.1, 0.23, 0.08, 0.02, 1472203899.47) before ax.plot
#+END_EXAMPLE
from os.times().  (the results are pretty stable: 1 second user; .2
seconds system)

otoh, matplotlib plotting itself is very fast.

ah, matplotlib taking a long time to start up?  printing message about
re-building font-cache?  [[http://stackoverflow.com/questions/34771191/matplotlib-taking-time-when-being-imported][here]] is a possible solution.

and, we have
#+BEGIN_EXAMPLE
bash greg-minshalls-mbp-2: {1782} ls ~/.matplotlib/
fontList.cache  matplotlibrc    tex.cache/
#+END_EXAMPLE

then
#+BEGIN_EXAMPLE
bash greg-minshalls-mbp-2: {1786} rm -rf ~/.matplotlib/*.cache
bash greg-minshalls-mbp-2: {1787} python
Python 2.7.12 (default, Jul 30 2016, 03:44:10) 
[GCC 4.2.1 Compatible Apple LLVM 7.3.0 (clang-703.0.31)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> from matplotlib import pyplot
/sw/lib/python2.7/site-packages/matplotlib/font_manager.py:278: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.
  warnings.warn('Matplotlib is building the font cache using fc-list. This may take a moment.')
>>> 
bash greg-minshalls-mbp-2: {1788} python
Python 2.7.12 (default, Jul 30 2016, 03:44:10) 
[GCC 4.2.1 Compatible Apple LLVM 7.3.0 (clang-703.0.31)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> from matplotlib import pyplot
>>> 
#+END_EXAMPLE
significant speedup!


** what to use as the display?

*** gnuplot?

a couple of packages.  [[http://gnuplot-py.sourceforge.net/][Gnuplot]] (fink: gnuplot-py27) seems nice.  otoh,
it doesn't support what i need "natively", so maybe [[https://github.com/jfindlay/gp.py][gp.py]] will be
better?

[[http://www.gnuplotting.org/tag/pm3d/][here]] is an article on plotting maps (from a site that has lots of
gnuplot tips, apparently).  [[http://www.gnuplotting.org/tag/object/][objects]] seem to be how to embed polygons
and such.

#+BEGIN_SRC python :results none
  import gp

  g = gp.GP(term='x11')

  g.write("set xrange [-1.5:4.5]")
  g.write("set yrange [-3:3]")
  g.write("set size ratio -1")

  g.write("a = 1.0/3")
  g.write(" \
  set object 1 polygon from \
      -1, 1 to \
       0, 1 to \
       0, a to \
       1, 1 to \
       1,-1 to \
       0,-a to \
       0,-1 to \
      -1,-1 to \
      -1, 1""")

  g.write("set object 1 fc rgb '#000000' fillstyle solid lw 0")

  g.write("set parametric")
  g.write("set trange [-pi/6:pi/6]")
  g.write("fx(t,r) = r*cos(t)")
  g.write("fy(t,r) = r*sin(t)")

  g.write("plot fx(t,2),fy(t,2) with lines ls 1, \
       fx(t,3),fy(t,3) with lines ls 1, \
       fx(t,4),fy(t,4) with lines ls 1")
#+END_SRC

#+name: GpShape
#+BEGIN_SRC python
  import gp

  class GpShape(gp.GP):
      """plotting Shapely objects using gnuplot.  for information on mouse
  binding you can try launching gnuplot and saying 'show bind'; also,
  see http://stackoverflow.com/a/23346921/1527747

      """

      def __init__(self, term='x11'):
          if term == None and term != "":
              gp.GP.__init__(self)
          else:
              gp.GP.__init__(self, term=term)
          self.reset()
          self.__setdefaults__()

      def reset(self):
          self.objid = 0
          gp.GP.write(self, "reset")
          gp.GP.write(self, "set size ratio -1")
          gp.GP.write(self, "set key outside")
          # https://groups.google.com/forum/#!topic/comp.graphics.apps.gnuplot/uPJ7oGaEC8o
          gp.GP.write(self, "unset border")
          gp.GP.write(self, "unset xtics")
          gp.GP.write(self, "unset ytics")
          self.minx = self.miny = self.maxx = self.maxy = None
          self.reppoint = None    # need a representative point for
                                  # plotting a blank page




      def __setdefaults__(self):
          defs = { 'fillstyle': "empty",
                   'fillcolor': "rgb 0x000000",
                   'transparency': 1.0,
                   'density': 1.0,
                   'border': "off",
                   'linecolor': "rgb 0x000000",
                   'linewidth': 1,
                   'legend': "off",
          }
          self.__defaults__ = defs;

      def setdefaults(self, **kwargs):
          """set one or more defaults for plotting; complex defaults should be
          specified as a single string (e.g., linecolor="rgbcolor
          0x000000").

          i don't want to duplicate all of gnuplot's parameters, since a
          "power user" can always just to g.write("...").  but, some
          things are fairly common.  use getdefaults() to see the
          defaults.

          so, plan is to have defaults from "compile" time, the ability
          to change the defaults (for subsequent calls this session),
          and the ability to specify a different value on each
          invocation of add)

          """
          # from Gnuplot.py's set()
          for (k,v) in kwargs.items():
              try:
                  type = self.defaults[k]
              except:
                  raise NameError("setdefaults: no default {0}".format(k))
              if type(v) != type(self.__defaults__[k]):
                  raise TypeError("key should be of type {0}, but {1} (of type {2}) passed".format(
                      type(self.__defaults__[k], v, type(v))))
              self.__defaults__[k] = v

      def getdefaults(self, *args):
          if (len(args)) == 0:
              return self.__defaults__
          else:
              results = {}
              for k in args.items():
                  try:
                      results.add(self.__defaults__[k])
                  except:
                      raise NameError("getdefaults: no default {0}".format(k))
              return results

      def __stylespec__(self, prefix, defs):
          """from defaults and options passed on call, put together a valid
  style spec

          """

          def ifel(k,v):
              if v == "":
                  return ""
              else:
                  return " {k} {v}".format(k=k,v=v)

          # now we have a complete list of options, turn them into a
          # style list.
          results = prefix        # first part of command line
          # ternary operator: http://stackoverflow.com/a/394814/1527747

          # fillstyle
          if defs['fillstyle'] in [None, "empty"]:
              results += " fillstyle empty"
          else:
              results += " fillstyle"
              if defs['transparency'] != 1:
                  # so, <density> is used to encode the transparency.
                  results += " transparent {f} {d}".format(f=defs['fillstyle'],
                                                           d=defs['transparency'])
              else:
                  results += " {f} {d}".format(f=defs['fillstyle'],
                                               d=defs['density'])
                  results += ifel('fillcolor', defs['fillcolor'])

          # linestyle (only if a border)
          if {defs['linecolor'], defs['linewidth']} != set([""]):
              # something isn't blank
              results += "\n{0} fillstyle".format(prefix)
              results += " border"
              results += ifel('linecolor', defs['linecolor'])
              results += ifel('linewidth', defs['linewidth'])
          return results


      def __minmax__(self, coords):
          """keep our minimums and maximums up to date"""
          # http://stackoverflow.com/a/26310202/1527747
          cminx = min([pair[0] for pair in coords])
          cminy = min([pair[1] for pair in coords])
          cmaxx = max([pair[0] for pair in coords])
          cmaxy = max([pair[1] for pair in coords])
          if self.minx == None or self.minx > cminx:
              self.minx = cminx
          if self.miny == None or self.miny > cminy:
              self.miny = cminy
          if self.maxx == None or self.maxx < cmaxx:
              self.maxx = cmaxx
          if self.maxy == None or self.maxy < cmaxy:
              self.maxy = cmaxy

      def __rewrite__(self, pairs, btw, inter):
          """from a sequence of PAIRS, pull them out and separate them with
      BTW, and the separate successive pairs with INTER."""
          def doit(x,y):
              """reduce routine.  need to distinguish first from successive calls.
              """
              if type(x) == tuple:
                  return "{0}{1}{2}{3}{4}{5}{6}".format(x[0], btw, x[1],
                                                        inter, y[0], btw, y[1])
              elif type(x) == str:
                  return "{0}{1}{2}{3}{4}".format(x, inter, y[0], btw, y[1])
              else:
                  raise TypeError("internal error: type s/b tuple or str")
          return reduce(doit, pairs)

      def __add__(self, shape, defs):
          """do the work to actually add shapely SHAPE geometries to the plot"""

          self.objid += 1         # make sure this happens
          if shape.type in ['MultiPoint', 'MultiLine', 
                            'MultiPolygon', 'GeometryCollection']:
              self.objid -= 1     # (but we don't want it here)
              for geom in shape.geoms:
                  self.__add__(geom, defs)  # recurse for each sub-geometry
          #elif shape.type == 'Point':   XXX
          #    pass
          #elif shape.type == 'Line':
          #    pass
          elif shape.type == 'Polygon': # gp.GP.write(self, ...):
              if self.reppoint == None:
                  self.reppoint = shape.exterior.coords[0]
              self.__minmax__(shape.exterior.coords)
              outstr = self.__rewrite__(shape.exterior.coords, ", ", " to ")
              # gp.py's write() call sleeps here (for O(size of string)
              # with the comment "gnuplot actions are nonblocking" so,
              # we short cut that here when writing out (potentialy)
              # thousands of points
              self.stdin.write("set object {i} polygon from {s}\n".format(i=self.objid,
                                                                          s=outstr))
              # set the style for that object
              prefix = "set object {i}".format(i=self.objid) # prefix to use
              styles = self.__stylespec__(prefix, defs)
              gp.GP.write(self, styles)
          else:
              # http://stackoverflow.com/a/24065533/1527747
              raise TypeError("type is '{0}', but we only support 'MultiPolygon' and 'Polygon'".format(shape.type))

      def __mergedefaults__(self, **kwargs):
          defs = self.__defaults__
          for (k,v) in kwargs.items():
              try:
                  defs[k] = v
              except:
                  raise NameError("unknown option {0}; use getdefaults() for list".format(k))
          return defs

      def add(self, shape, **kwargs):
          """plot the shapely SHAPE object"""
          defs = self.__mergedefaults__(**kwargs)
          self.__add__(shape, defs)


      def plot(self, **kwargs):
          defs = self.__mergedefaults__(**kwargs)

          if defs['legend'] != None and defs['legend'] != "":
              gp.GP.write(self, "set key {0}".format(defs['legend']))

          gp.GP.write(self, "set xrange [{x}:{X}]".format(x=self.minx, X=self.maxx))
          gp.GP.write(self, "set yrange [{y}:{Y}]".format(y=self.miny, Y=self.maxy))


          # "How do I produce blank output page?"
          # http://gnuplot.info/faq/faq.html#x1-760006.9
          gp.GP.write(self, "plot [][] {0}".format(self.reppoint))

          # a problem is that when this process terminates, the plot
          # window tends to disappear.  the following, in the case of
          # running under gp.py under python, leaves the window up (and
          # still tracking mouse movements).
          gp.GP.write(self, "\n pause mouse close") # leave window running
          gp.GP.write(self, "\n exit")              # and, exit
          # and, wait for window to close
          gp.GP.read(self)
#+END_SRC

ah, [[http://gnuplot-surprising.blogspot.de/2011/09/gnuplot-background-image.html][gnuplot *can* plot images]]!!  now, how to get coordinates to match up...

okay, gnuplot info file (commands:plot:binary:keywords) talks about
"dx dy dz" and "origin", which may help with coordinates.

*** PyPlot == ShPyPlot, plot shapely shape

#+name: PpShape
#+BEGIN_SRC python

  class PpShape:
      """plotting Shapely objects using pyplot."""

      def __init__(self):
          self.reset()
          self.__setdefaults__()

      def reset(self):
          from matplotlib import pyplot
          self.fig = pyplot.figure(1, figsize=(5,5), dpi=90)
          # for '111': http://stackoverflow.com/a/6981055/1527747
          # for 'aspect=1.0': http://stackoverflow.com/q/7965743/1527747
          self.ax = self.fig.add_subplot(111, aspect=1.0)
          self.minx = self.maxx = self.miny = self.maxy = None

      def __setdefaults__(self):
          defs = {
              'color': '#000000',
              'alpha': 0.7,
              'linewidth': 1,
              'solid_capstyle': 'round',
              'zorder': 2,
          }
          self.__defaults__ = defs;

      def setdefaults(self, **kwargs):
          """set one or more defaults for plotting; complex defaults should be
          specified as a single string (e.g., linecolor="rgbcolor
          0x000000").

          so, plan is to have defaults from "compile" time, the ability
          to change the defaults (for subsequent calls this session),
          and the ability to specify a different value on each
          invocation of add)

          """

          for (k,v) in kwargs.items():
              try:
                  type = self.defaults[k]
              except:
                  raise NameError("setdefaults: no default {0}".format(k))
              if type(v) != type(self.__defaults__[k]):
                  raise TypeError("key should be of type {0}, but {1} (of type {2}) passed".format(
                      type(self.__defaults__[k], v, type(v))))
              self.__defaults__[k] = v

      def getdefaults(self, *args):
          if (len(args)) == 0:
              return self.__defaults__
          else:
              results = {}
              for k in args.items():
                  try:
                      results.add(self.__defaults__[k])
                  except:
                      raise NameError("getdefaults: no default {0}".format(k))
              return results

      def __stylespec__(self, prefix, defs):
          """from defaults and options passed on call, put together a valid
  style spec

          """

          def ifel(k,v):
              if v == "":
                  return ""
              else:
                  return " {k} {v}".format(k=k,v=v)

          # now we have a complete list of options, turn them into a
          # style list.
          results = prefix        # first part of command line
          # ternary operator: http://stackoverflow.com/a/394814/1527747

          # fillstyle
          if defs['fillstyle'] in [None, "empty"]:
              results += " fillstyle empty"
          else:
              results += " fillstyle"
              if defs['transparency'] != 1:
                  # so, <density> is used to encode the transparency.
                  results += " transparent {f} {d}".format(f=defs['fillstyle'],
                                                           d=defs['transparency'])
              else:
                  results += " {f} {d}".format(f=defs['fillstyle'],
                                               d=defs['density'])
                  results += ifel('fillcolor', defs['fillcolor'])

          # linestyle (only if a border)
          if {defs['linecolor'], defs['linewidth']} != set([""]):
              # something isn't blank
              results += "\n{0} fillstyle".format(prefix)
              results += " border"
              results += ifel('linecolor', defs['linecolor'])
              results += ifel('linewidth', defs['linewidth'])
          return results


      def __minmax__(self, coords):
          """keep our minimums and maximums up to date"""
          # http://stackoverflow.com/a/26310202/1527747
          cminx = min([pair[0] for pair in coords])
          cminy = min([pair[1] for pair in coords])
          cmaxx = max([pair[0] for pair in coords])
          cmaxy = max([pair[1] for pair in coords])
          if self.minx == None or self.minx > cminx:
              self.minx = cminx
          if self.miny == None or self.miny > cminy:
              self.miny = cminy
          if self.maxx == None or self.maxx < cmaxx:
              self.maxx = cmaxx
          if self.maxy == None or self.maxy < cmaxy:
              self.maxy = cmaxy

      def __add__(self, shape, defs):
          """do the work to actually add shapely SHAPE geometries to the plot"""

          if shape.type in ['MultiPoint', 'MultiLine', 
                            'MultiPolygon', 'GeometryCollection']:
              for geom in shape.geoms:
                  self.__add__(geom, defs)  # recurse for each sub-geometry
          #elif shape.type == 'Point':   XXX
          #    pass
          #elif shape.type == 'Line':
          #    pass
          elif shape.type == 'Polygon': # gp.GP.write(self, ...):
              self.__minmax__(shape.exterior.coords)
              # XXX defaults here...
              ignore = self.ax.plot(
                  map(lambda x: x[0], shape.exterior.coords),
                  map(lambda y: y[1], shape.exterior.coords), **defs)
          else:
              # http://stackoverflow.com/a/24065533/1527747
              raise TypeError("type is '{0}', but we only support 'MultiPolygon' and 'Polygon'".format(shape.type))

      def __mergedefaults__(self, **kwargs):
          defs = self.__defaults__
          for (k,v) in kwargs.items():
              try:
                  defs[k] = v
              except:
                  raise NameError("unknown option {0}; use getdefaults() for list".format(k))
          return defs

      def add(self, shape, **kwargs):
          """plot the shapely SHAPE object"""
          defs = self.__mergedefaults__(**kwargs)
          self.__add__(shape, defs)

      def addimage(self, image, **kwargs):
          print "xlim, ylim: ", self.ax.get_xlim(), self.ax.get_ylim()
          self.ax.imshow(image, **kwargs)

      def plot(self, **kwargs):
          from matplotlib import pyplot
          defs = self.__mergedefaults__(**kwargs)

          ignore = self.ax.set_title('Polygon')
          pyplot.show()
#+END_SRC


** maps?

how do we get our polygon positioned over a map (in the background).
[[http://www.gnuplotting.org/tag/pm3d/][here's]] *something* of that order.

[[http://wrobell.it-zone.org/geotiler/][geotiler]] is based on "modest maps".  it uses [[http://redis.io/][redis]] as a cache.
(there's also [[http://tilecache.org/][tilecache]] that one can use as a WMS tile cache.)

one can [[http://stackoverflow.com/a/21768191/1527747][draw polygons in PIL]].  (really, in [[https://github.com/python-pillow/Pillow][Pillow]].)  sadly, though, as
built on fink, it uses Preview to display images.

([[http://opencv-python-tutroals.readthedocs.io/en/latest/index.html][opencv]] ([[http://opencv.org/][home page]]) is another image library for python.)

so, use geotiler to get image, then plot.

for matplotlib, [[http://www.labri.fr/perso/nrougier/teaching/matplotlib/][here]] is something talking about maps, pointing at
[[http://matplotlib.org/basemap/][basemap]] and [[http://scitools.org.uk/cartopy/][cartopy]].  [[http://matplotlib.org/users/transforms_tutorial.html#the-transformation-pipeline][here]] is *maybe* how one would transform
coordinates in matplotlib.

cartopy has an img_tiles() routine that maybe pulls down OSM data?
and, [[http://scitools.org.uk/cartopy/docs/latest/matplotlib/intro.html][it works]] with mapplotlib.

[[http://matplotlib.org/basemap/users/mapcoords.html][here]] is a basemap example of aligning the coordinates (using
basemap).  but, the basemap fink tar file is some 100MB in size!  i
think i do need data from OSM.

need to get the portion of map.  Google Earth displays:
#+name: cornersindegrees
| nw | 36 34'36.00 N | 122 04'13.08 W |
| se | 36 09'00.00 N | 121 23'51.80 W |


whereas my point files have things like:
- -121.858129504874995, 36.445399181157804

*** getting OSM tiles

[[http://wiki.openstreetmap.org/wiki/Slippy_Map][the wiki entry on Slippy Maps]] says the tile server is on
[[http://tile.openstreetmap.org]], which one accesses with the appropriate
[[http://ojw.dev.openstreetmap.org/StaticMap/?mode=API][API]].

so, try to cons up a URL

http://tile.openstreetmap.org/?show=1&lat=36.4&lon=-121&w=800&h=600&layer=hiking&fmt=png&filter=none&lang=en&att=logo

on the other hand, [[https://wiki.openstreetmap.org/wiki/Tiles][*this* page]] says the format is different (in the
"tiles url" column of the table "Servers"):

http://a.tile.openstreetmap.org/0/-121/36.png

hmm.  that didn't work.  from the same table, try wiki

https://maps.wikimedia.org/osm-intl/0/-121/36.png

yet another [[http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames][OSM wiki page]], yet another format?  i guess x can't be
zero, it goes from 0 (180 degrees) to 2^zoom.  y goes from 0 

https://maps.wikimedia.org/osm-intl/7/61/36.png

which more or less seems to work.  the same page give code in *all*
available languages on how to do this.  here is the python.

turns out mapproxy needs something slightly different.  hmm, it is
using *huge* coordinates:
#+BEGIN_EXAMPLE
bash greg-minshalls-mbp-2: {1022} mapproxy-util grids -f mapproxy.yaml
webmercator:
    Configuration:
        base: 'GLOBAL_WEBMERCATOR'
        bbox*: [-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244]
        origin*: 'ul'
        tile_size*: [256, 256]
    ...
#+END_EXAMPLE

http://127.0.0.1:8080/tms/1.0.0/osm/webmercator/0/0/0.png this should
be the whole world.  instead, what i get is South America and part of
Antarctica.  ah, but i'm using the wrong scheme with mapproxy.  i
should be using
http://localhost:8080/tiles/osm/webmercator/0/0/0.png.  now it works.

#+name: deg2url
#+BEGIN_SRC python :var lat=36.4 :var lon=-121.858 :var zoom=5 :var mapurl=MAPURL
  <<tilebbox>>
  x,y = Tilebbox.deg2tilexy(lat, lon, zoom)
  return "{m}/{z}/{x}/{y}.png".format(m=mapurl, z=zoom, x=x, y=y)
#+END_SRC

#+RESULTS: deg2url

#+CALL: deg2url(zoom=15)

#+RESULTS:
: http://localhost:8080/tiles/osm/webmercator/15/5292/12822.png

Okay.  but, i'd better put up some sort of cache before going much
further.

*** caching

**** [[http://redis.io/][redis]]

if we use redis, define a cache directory, add .png files there, then
add index in redis.  but, then we need to deal with cleaning the
cache.  still, might be the thing to do.  we could add the file
pointer with an expire time (for stale), maybe derived from whatever
web response says (yuck), and the time of last use (for flushing
unused entries), then occasionally run this, deleting stale or unused
entries.

**** [[http://tilecache.org/][tilecache]]  ([[https://pypi.python.org/pypi/TileCache][on pypi.python.org]])

seems nice.  a bit long in the tooth, though (copyright says
2006-2010).  it can talk CGI, but also [[https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface][WSGI]].

need to install [[https://pypi.python.org/pypi/Paste][Paste]] (fink has it).  done.

in TileCache/Service.py, sX/usr/bin/pythonX/usr/bin/env pythonX

don't really want to [[https://dubroy.com/blog/so-you-want-to-install-a-python-package/][install]] tilecache on system.  but, maybe i
should.  okay, try installing on system.  "sudo pip install
TileCache", okay, i expect that.  but, then need to
#+BEGIN_EXAMPLE
bash greg-minshalls-mbp-2: {1014} tilecache_install_config.py
Unable to open destination file /etc/tilecache.cfg. Perhaps you need permission to write there?
(Error was: [Errno 13] Permission denied: '/etc/tilecache.cfg')
#+END_EXAMPLE
so, need to run that su.  sigh.

that didn't work so well...
#+BEGIN_EXAMPLE
bash greg-minshalls-mbp-2: {1015} sudo tilecache_install_config.py
Unable to open source file.
(Error was: [Errno 2] No such file or directory: '/sw/lib/python2.7/site-packages/TileCache/tilecache.cfg')
#+END_EXAMPLE

yuck:
#+BEGIN_EXAMPLE
grep tilecache.cfg /sw/lib/python2.7/site-packages/TileCache-2.11-py2.7.egg-info/*
...
/sw/lib/python2.7/site-packages/TileCache-2.11-py2.7.egg-info/installed-files.txt:../../../../TileCache/tilecache.cfg
bash greg-minshalls-mbp-2: {1019} ls /sw/TileCache/
tilecache.cfg
#+END_EXAMPLE

so, sudo mv back to where it should have been.
#+BEGIN_EXAMPLE
bash greg-minshalls-mbp-2: {1020} sudo mv /sw/TileCache/tilecache.cfg /sw/lib/python2.7/site-packages/TileCache/
bash greg-minshalls-mbp-2: {1021} sudo rm /sw/TileCache/
rm: /sw/TileCache/: is a directory
bash greg-minshalls-mbp-2: {1022} sudo rmdir /sw/TileCache/
#+END_EXAMPLE

okay.  installed, with default tilecache.cfg.  but, following the example:
#+BEGIN_EXAMPLE
python tilecache_http_server.py
#+END_EXAMPLE
then, going to [[http://localhost:8080/1.0.0/basic/0/0/0.png]] is timing
out.

/etc/tilecache.cfg has only one map server unmapped out:
#+BEGIN_EXAMPLE
type=WMS
url=http://labs.metacarta.com/wms/vmap0
extension=png
#+END_EXAMPLE

and, that server doesn't appear to be existing.  right, that company
appears to have gone under, or been absorbed.

**** [[http://www.tornadoweb.org/en/stable/][tornado]] web server

tilecache, at least, needs a web server.  maybe tornado (which is
installed).  it has a native app interface, but also talks [[https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface][WSGI]].
(actually, tilecache can use its [python's?] own.)

**** [[https://mapproxy.org/][mapproxy]]

mapproxy is another candidate.  seems to be more recently developed.
installs easily.  the following puts up nice screen (but, no maps
yet!):
#+BEGIN_EXAMPLE
sudo aptitude install python-imaging python-yaml libproj0
sudo easy_install mapproxy
mapproxy-util create -t base-config ./
mapproxy-util serve-develop ./mapproxy.yaml
#+END_EXAMPLE



*** map sources

**** omniscale

to keep osm happy, i'll sign up for the (mapproxy default?)
[[https://maps.omniscale.com/en][Omniscale]].  it says this is my url for wms services:

**** [[https://wiki.openstreetmap.org/wiki/Static_map_images][static maps]]

OSM static maps are another possible solution.  the [[http://staticmap.openstreetmap.de/][.de version]]
possibly offers topo maps:
: staticmap.openstreetmap.de/staticmap.php?center=36.4,-121.858&zoom=14&size=865x512&maptype=topo

#+name:WMSurl
#+BEGIN_EXAMPLE
http://maps.omniscale.net/v2/private-greg-minshall-c3613e25/style.default/map 
#+END_EXAMPLE

start mapproxy via

: mapproxy-util serve-develop ./mapproxy.yaml


*** now, how do we fill a screen with this stuff??

we know how to get one tile.  but, that is the small part of a
screen.  presumably, e.g., Leaflet figures out the size of the screen,
or its window.  we'll just fudge

then, given a set of coordinates, that we want in the center of the
screen, and a zoom level, figure out the list of tiles we need to
request.

**** TilePoint -- an experiment in progress

#+name: tilepoint
#+BEGIN_SRC python
  class TilePoint:
      """implements arithmetic for tiles that wrap around.  for longitude,
  this is just basically modulo (2**zoom) arithmetic.  trickier is for
  latitude.  for example, with zoom 3 (2**3 = 8) if you are at
  latitude 0, and want to go "up" one tile (by subtracting by (0,1),
  say), you should *not* end up at (0, 7), *nor* should you end up at
  (4,7).  rather, you should end up at (4,0).  but, *then*, on the next
  subtraction by (0,1), you should end up at (4,7).  possibly it's not
  possible.

      """
      def __init__(self, x, y, zoom):
          self.x = x
          self.y = y
          self.zoom = zoom
          self.powzoom = 2**zoom  # for efficiency
          self.halves = self.powzoom/2 # ditto
          self.doubles = self.powzoom*2 # ditto

      def __sameside__(self, y1, y2):
          """are two latitudes on the same half of the planet?  the model is
          that the latitudes wrap around the N and S poles"""
          s1 = int(y1/self.powzoom)%2
          s2 = int(y2/self.powzoom)%2
          # print "sameside({0}, {1}), s1 {2}, s2 {3}".format(y1, y2, s1, s2)
          return s1 == s2

      def __add__(self, ij):
          i,j = ij
          rval = TilePoint(self.x, self.y, self.zoom)
          # so, we're going to do this very slowly
          if i < 0:
              # subtraction of |i| is like addition of modulus - |i|
              i = rval.powzoom+i
          if j < 0:
              j = rval.powzoom+j  # ditto

          # okay, at most once (-1) around the world
          i = i % rval.powzoom
          j = j % rval.doubles    # here, we might go a bit further

          rval.x += i             # longitude trivial (we do modulus
                                  # reduction towards end of function,
                                  # as we may yet mess with x)

          # if we wrap below S pole, we move from, say, (0, 3) to "(4,
          # 0)", i.e. to that tile just on the other side of the S pole.
          # but, that tile has a *different* name over there, namely,
          # (4,3).  and, on *that* side, we are *subtracting* in the y
          # coordinate when we are adding from *this* side.  detect
          # this.
          if rval.__sameside__(rval.y, rval.y+j):
              rval.y += j         # easy case, on same side, just add
          else:
              rval.x += rval.halves    # other side of world
              # next, get to the first tile beyond S pole ...
              j -= (rval.powzoom-rval.y)
              rval.y = rval.powzoom-1; # .. a tile called this
              rval.y -= j         # then, "advance backwards" the rest
                                  # of our journey
          # now, make sure we're in bounds
          rval.y %= rval.powzoom
          rval.x %= rval.powzoom
          return rval

      def __sub__(self, ij):
          i,j = (ij)
          return self.__add__((-i, -j))

      def __str__(self):
          return "({0}, {1}, {2})".format(self.x, self.y, self.zoom)
#+END_SRC


#+BEGIN_SRC python
  <<tilepoint>>
  res = []
  one = TilePoint(0, 0, 3)
  for iy in range(2**6):
          two = one + (0, iy)
          res += [[0, iy, two.x, two.y]]
  return res
#+END_SRC

**** SlippyMaps

from [[http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames][Slippy map tilenames]] page, some parameters of the algorithm:

#+name: slippyparms
| xzerodeg |                                       -180.0 |                     |
| xmaxdeg  |                                        180.0 |                     |
| yzerodeg |  math.degrees(math.atan(math.sinh(math.pi))) | mercator projection |
| ymaxdeg  | -math.degrees(math.atan(math.sinh(math.pi))) | ditto               |
| tilex    |                                          256 |                     |
| tiley    |                                          256 |                     |

#+name: slippymaps
#+BEGIN_SRC python :var slippyparms=slippyparms
  def wgs2merc(wlat, wlon):
      """convert (lat, lon) in WGS84/EPSG:4326 coordinates to
  Mercator/EPSG:3857 coordinates

      """

      import math

      mlon = wlon                 # identity transform

      wlatrad = math.radians(wlat)
      mlatrad = math.log(math.tan(wlatrad)+(1/math.cos(wlatrad)))
      mlat = math.degrees(mlatrad)

      return mlat, mlon

  def merc2wgs(mlat, mlon):
      """convert (lat, lon) in Mercator/EPSG:3857 coordinates to
  WGS84/EPSG:4326 coordintes"""

      import math

      wlon = mlon                 # identify transform

      mlatrad = math.radians(mlat)
      wlatrad = math.atan(math.sinh(mlatrad))
      wlat = math.degrees(wlatrad)

      print "merc2wgs (mlat, mlon), mlatrad, wlatrad, (wlat, wlon): ", (mlat, mlon), mlatrad, wlatrad, (wlat, wlon)

      return (wlat, wlon)

  def merclatlon2tilexy(mlat, mlon, zoom):
      """given a *Mercator* (lat, lon), return the (tilex, tiley) that holds
  this location

      """
      import math

      mlonrad = math.radians(mlon)
      mlatrad = math.radians(mlat)

      x = (1.0 + (mlonrad/math.pi))/2.0
      y = (1.0 - (mlatrad/math.pi))/2.0

      n = 2**zoom

      tilex = math.floor(x*n)
      tiley = math.floor(y*n)

      print "merclatlon2tilexy (mlat, mlon, zoom), (tilex, tiley): \n", (mlat, mlon, zoom), (tilex, tiley)
      return (tilex, tiley)

  def tilexy2nwmerclatlon(tilex, tiley, zoom):
      """given a (TILEX, TILEY) of a tiling at ZOOM, return the Mercator
  (lat, lon) of its *northwest* corner"""

      import math

      n = 2**zoom
      mlonrad = ((((tilex*1.0)/n)*2.0)-1.0)*math.pi
      mlatrad = (1-(((tiley*1.0)/n)*2.0))*math.pi

      mlon = math.degrees(mlonrad)
      mlat = math.degrees(mlatrad)

      print "tilexy2nwmerclatlon (tilex, tiley, zoom), (mlat, mlon): ", (tilex, tiley, zoom), (mlat, mlon)

      return (mlat, mlon)
#+END_SRC

**** TileBbox

#+name: tilebbox
#+BEGIN_SRC python :results output verbatim
  <<tilepoint>>
  <<slippymaps>>
  class TileBbox:                    # a Tile Bounding Box
      def __init__(self, lat, lon, zoom):
          self.__tilebbox__(lat, lon, zoom)

      def __iter__(self):
          for ix in range(self.wit):
              for iy in range(self.hit):
                  sum = self.tpt+(ix, iy)
                  yield(sum.x, sum.y, ix, iy)
      # @staticmethod versus @classmethod
      # http://stackoverflow.com/a/12179752/1527747

      def dnwlatlon(self):
          """return the lat/lon coordinates, in *data* space, of the nw corner
    of this box

          """
          print "dnwlatlon at input: ", self.tpt.x, self.tpt.y, self.zoom
          mlat, mlon = tilexy2nwmerclatlon(self.tpt.x, self.tpt.y, self.zoom)
          print "dnwlatlon returning: ", merc2wgs(mlat, mlon)
          return merc2wgs(mlat, mlon)

      def dselatlon(self):
          """return the lat/lon coordinates, in *data* space, of the se corner of
    this box

          """
          se = self.tpt+(self.wit, self.hit) # tile just se of our se
          # (its nw == our se) XXX
          mlat, mlon = tilexy2nwmerclatlon(se.x, se.y, self.zoom)
          return merc2wgs(mlat, mlon)

      def tilexyfixup(self, xtile, ytile, zoom):
          import math
          n = 2**zoom

          # print "tilexyfixup: called with: xtile, ytile, zoom: ", xtile, ytile, zoom
          # deal with wrapping
          if xtile < 0:
              # if *x* is negative, reflect around x axis (redundantly, see below)
              xtile %= n

          if ytile < 0 or ytile > n:
              # first, do we need to go to the other side of the world?
              nhalves = int(ytile/(n/2.0))  # how many halves of earth did we wrap?
              # print "nhalves ", nhalves
              if nhalves%2 == 0:
                  # yes, on the other side of the world
                  xtile += n/2
              # if *y* out of bounds, negative, reflect around y axis, which
              # basically means absolute value (so, the distance to the relevant
              # pole stays the same)
              if ytile < 0:
                  ytile = abs(ytile)        # reflect around the N pole
              else:
                  ytile = n - (ytile%n)     # reflect around the S pole

          # make sure we're in 1..2**zoom
          xtile %= n
          ytile %= n

          xtile = int(xtile)
          ytile = int(ytile)

          # print "tilexyfixup returning (xtile, ytile): ", xtile, ytile

          return (xtile, ytile)


      def deg2tilexy(self, lat_deg, lon_deg, zoom):
          """give lat/lon (in decimal) and a zoom, return the tilex and tiley coordinates of the required tile"""

          lat_rad, lon_rad = wgs2merc(lat_deg, lon_deg)

          return merclatlon2tilexy(lat_rad, lon_rad, zoom)

      def __tilebbox__(self, lat, lon, zoom):
          """given (LAT, LON), a set of coordinates, and ZOOM, a [proposed] zoom
          level, return the "bounding box" of tiles we want to fill the
          screen.  we *also* return a (possibly) updated zoom level, in case
          the input zoom level was so small that it wouldn't support filling
          the whole screen

          """

          import math

          zoomexp = 2**zoom            # just for convenience

          tcenterx,tcentery = self.deg2tilexy(lat, lon, zoom)
          # print "deg2tilexy(lat, lon, zoom)", lat, lon, zoom, " ==> tcenterx, tcentery", tcenterx, tcentery

          # so, tcenterx,tcentery is tile coordinates of the center of the map.  now get
          # the height of the screen in tiles.  (in case you're wondering,
          # sorry "[screen] width in tiles", "[screen] height in tiles")
          wit = int(math.ceil((p['screenx']*1.0)/(p['tilex']*1.0)))
          hit = int(math.ceil((p['screeny']*1.0)/(p['tiley']*1.0)))
          wit = max(wit, 3)
          hit = max(hit, 3)       # enforce some minimum
          if wit % 2 == 0:
              wit += 1
          if hit % 2 == 0:        # enforce oddness, so we *have* a
              hit += 1            # center XXX

          if wit >= zoomexp or hit >= zoomexp:
              # *** if we've zoomed out too far, recurse at a higher zoom level
              self.__tilebbox__(lat, lon, zoom+1)
          else:
              # print "wit, hit: ", wit, hit
              tnwx, tnwy = (tcenterx - ((wit-1)/2), tcentery - ((hit-1)/2))

              # check to see if we are zoomed too far out, wrapped around, or some such
              # print "(before tilexyfixup) tnwx, tnwy: ", tnwx, tnwy
              tnwx, tnwy = self.tilexyfixup(tnwx, tnwy, zoom)
              # print "(after tilexyfixup) tnwx, tnwy: ", tnwx, tnwy

              self.tpt = TilePoint(tnwx, tnwy, zoom)
              self.wit = wit
              self.hit = hit
              self.zoom = zoom
#+END_SRC


#+BEGIN_SRC python :results output verbatim :var lat=36 :var lon=-121 :var zoom=10 :var parms=parameters
  <<tilebbox>>

  p = {}
  for i in parms:
      p[i[0]] = i[1]

  tbox = TileBbox(lat, lon, zoom)

  print lat, lon, zoom, tbox.dnwlatlon(), tbox.dselatlon(), tbox.tnwx, tbox.wit, tbox.tnwy, tbox.hit

#+END_SRC

#+RESULTS:
: 36 -121 10 (36.5978891330702, -121.9921875) (35.17380831799959, -120.234375) 165 5 400 5

#+name: MAPURL
: http://localhost:8080/tiles/osm/webmercator

#+name: parameters
| aspect  |    1 | x:y     |
| screenx | 1200 | pixels  |
| screeny |  800 | pixels  |
| tilex   |  256 | pixels? |
| tiley   |  256 | pixels? |

#+name: getmapimage
#+BEGIN_SRC python :results output verbatim :var lat=36.4 :var lon=-121.858 :var zoom=5 :var parms=parameters :var mapurl=MAPURL
  def getmapimage(lat, lon, zoom):
     """return a map that more-or-less centers LAT/LON at a particular ZOOM
  level.  also returns the bounding box (nw, se coordinates) of the
  image.

     """
     import io
     import PIL.Image
     import urllib2

     <<tilebbox>>
     p = {}
     for i in parms:
        p[i[0]] = i[1]

     # get bounding box and zoom
     tbox = TileBbox(lat, lon, zoom) # XXX should pass shape bounding box to TileBbox
     print "tilebbox tpt, wit, hit, zoom: ", tbox.tpt, tbox.wit, tbox.hit, tbox.zoom

     # PIL's Image.paste() seems to be what we want for laying out our
     # images: http://pillow.readthedocs.io/en/latest/reference/Image.html
     # (maybe starting by creating an image with Image.new()?)

     iwp = p['tilex']*tbox.wit
     ihp = p['tiley']*tbox.hit

     im = PIL.Image.new("RGB", (iwp, ihp))

     # now, run through the list of tiles.  for each tile, download it,
     # then paste it into the right place in the image.

     for tx, ty, xoff, yoff in tbox:
        # print "iter tx, ty, xoff, yoff: ", tx, ty, xoff, yoff
        # http://stackoverflow.com/a/22682/1527747
        url = "{u}/{z}/{x}/{y}.png".format(u=mapurl, z=tbox.zoom, x=tx, y=ty)
        response = urllib2.urlopen(url)
        data = response.read()
        # [[http://pillow.readthedocs.io/en/latest/reference/Image.html][PIL.Image.frombytes()
        # doc]] says: Note that this function decodes pixel data only,
        # not entire images. If you have an entire image in a string,
        # wrap it in a BytesIO object, and use open() to load it.
        bio = io.BytesIO(data)
        im2 = PIL.Image.open(bio)
        # now, paste this in the right place on the big image
        im.paste(im2, box=(xoff*p['tilex'], yoff*p['tiley']))

     print "tbox.dnwlatlon, dselatlon: ", tbox.dnwlatlon(), tbox.dselatlon()
     return (im, tbox.dnwlatlon(), tbox.dselatlon())
#+END_SRC

#+RESULTS: getpngs

#+call: getpngs(zoom=13)

#+RESULTS:

#+BEGIN_SRC python :results output verbatim :var parms=parameters
  <<tilebbox>>

  p = {}
  for i in parms:
     p[i[0]] = i[1]
  print TileBbox(0, 90, 0)
#+END_SRC

#+RESULTS:
#+begin_example
tilexyfixup:  0 0 0
0 0
0 90 0  ==>  0 0
tilexyfixup:  1 1 1
1 1
0 90 1  ==>  1 1
tilexyfixup:  3 2 2
3 2
0 90 2  ==>  3 2
wit, hit:  3 3
2 1
tilexyfixup:  2 1 2
2 1
2 1
<__main__.Tilebbox instance at 0x10c31ad88>
#+end_example

*** converting from degrees minutes seconds to decimal lat/lon

so: concat numbers after "'" as in [0,1) (by prepending a decimal
point), divide by .6, add to number between "deg" and "'", and divide
by 60.

#+name: deg2latlon
#+BEGIN_SRC python :tangle deg2latlon.py
  def deg2latlon(*args):
      import re

      regexp = "^([0-9]+)\s+([0-5][0-9])'([0-5][0-9])\.([0-9]{2})\s*([NWSEnwse])$"

      results = []
      for istr in args:
          matched = re.match(regexp, istr)

          if matched == None:
              raise ValueError("invalid lat/lon spec '{0}'".format(istr))

          vals = matched.group(1,2,3,4,5)
          secs = (float(int(vals[2]))+ ((float(int(vals[3])))/100.0))
          dsecs = secs/60.0
          mins = (float(int(vals[1])))+dsecs
          deg = float(int(vals[0])) + (mins/60.0)
          richtung = vals[4]

          if richtung in "SWsw":          # here we're in negative territory
              deg = -deg
          results += [deg]
      return results
#+END_SRC

#+BEGIN_SRC python :tangle deg2latlon  :shebang "#!/usr/bin/env python"
  <<deg2latlon>>
  def main(argv):
      print deg2latlon(*argv[1:])

  if __name__ == "__main__":
      import sys
      main(sys.argv)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output :var degrees=cornersindegrees :results output
  import deg2latlon

  corners = {degrees[0][0]: deg2latlon.deg2latlon(degrees[0][1], degrees[0][2]),
             degrees[1][0]: deg2latlon.deg2latlon(degrees[1][1], degrees[1][2])}

  print corners
#+END_SRC

#+RESULTS:
: ("36 34'36.00 N", "122 04'13.08 W")
: ("36 09'00.00 N", "121 23'51.80 W")
: {'se': [36.15, -121.39772222222223], 'nw': [36.57666666666667, -122.0703]}

openstreetmap has a
[[http://ojw.dev.openstreetmap.org/StaticMap/?api=json][page]] that
describes their
[[http://ojw.dev.openstreetmap.org/StaticMap/?mode=API][map tile
protocol]] in JSON.

*** converting from decimal lat/lon to a position on the screen

given a lat/lon (in decimal), and a zoom level, find the screen pixel
coordinates.

the [[http://wiki.openstreetmap.org/wiki/Zoom_levels][osm wiki zoom level page]] lists, e.g., meters/tile for each zoom level,
and says that
: S=C*cos(y)/2^(z+8)
where
- S = meters/pixel
- C = circumference of the earth = [[https://en.wikipedia.org/wiki/Equator#Exact_length_of_the_Equator][40075.016686 km]]
- z = zoom level
- y = latitude

the above osm wiki page points at [[http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Resolution_and_Scale][this other page]] for better
algorithms, etc., which gives this formula
: resolution = 156543.03 meters/pixel * cos(latitude) / (2 ^ zoomlevel)

(of course, *i* have coordinates in lat/lon, *not* meters.  still...)

*** misc

** putting it all together?

here, we try to get a PNG file, put it in the background, with the
[[http://stackoverflow.com/a/32652903/1527747][right coordinates]], and then overlay our feature over it.

#+name: ppShPolyMap
#+BEGIN_SRC python :tangle ppshpolymap :var parms=parameters :var mapurl=MAPURL :shebang "#!/usr/bin/env python"
  import os

  <<extractshape>>
  <<getmapimage>>
  <<PpShape>>

  def main(argv):
      import os, sys
      import argparse

      cmd = argv[0]
      parser = argparse.ArgumentParser(description="""display a geometry over a map.
      `{0} -l Soberanes -f "Heat Perimeter" ~/work/gis/play/IR/20160729_Soberanes_IR/doc.kml\'""".format(cmd))
      parser.add_argument('-l', '--layername', type=str, required=True,
                          help="name of desired layer (in file)")
      parser.add_argument('-f', '--featurename', type=str, required=True,
                          help="name of desired feature (within layer)")
      parser.add_argument('-z', '--zoom', type=int, default=10,
                          help="zoom level (0=zoomed out; default 10)")
      # use "type=str" since we use the file name for ogr.Open()
      parser.add_argument('filename', type=str, nargs=1)
      args = parser.parse_args();

      # get shape from extractshape()
      shape = extractshape(args.filename[0], args.layername, args.featurename)

      # get centroid from shape
      (lat, lon) = (shape.centroid.y, shape.centroid.x)

      # get image from getmapimage; returns image, plus the tilebbox (in lat/lon) of image
      (image, (dnwlat, dnwlon), (dselat, dselon)) = getmapimage(lat, lon, args.zoom)

      # call shPoly on the shape
      pp = PpShape()
      pp.add(shape)
      # problem: lat == y, lon == x, yet we're used to saying "lat/lon",
      # as well as to saying "x, y"
      print "dnwlon, dnwlat, dselon, dselat: ", dnwlon, dnwlat, dselon, dselat
      pp.addimage(image, aspect=1.0, extent=[dnwlon, dselon, dselat, dnwlat])
      pp.plot()

  if __name__ == "__main__":
      import sys
      main(sys.argv)
#+END_SRC

#+RESULTS: ppShPolyMap

** misc

from [[http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames][osm wiki page]], the degrees covered by a tile in (x,y) is:
: 360/2n x 170.1022/2n

#+name: testcalcs
#+BEGIN_SRC python
  <<tilebbox>>
  def diffs(packed):
      return (packed[0]-packed[2], packed[1]-packed[3])

  def calcbyalgorith(nwlat, nwlon, zoom):
      if hwit == None:
          raise ValueError("calcbyalgorith() called before global variable hwit set (should be set by calbytbbox?)")

      xnum = 360.0
      ynum = 170.1022

      denom = 2**zoom

      perxtile = xnum/denom
      perytile = ynum/denom

      selat = nwlat - (hwit*perytile)
      selon = nwlon + (hwit*perxtile)

      print "perytile, perxtile: ", perytile, perxtile
      return (nwlat, nwlon, selat, selon)


  def calcbytbbox(nwlat, nwlon, izoom):
      global hwit, zoom

      tbbox = TileBbox(nwlat, nwlon, izoom)
      if tbbox.hit != tbbox.wit:
          raise ValueError("tbbox hit ({0}) != tbbox.wit ({1})".format(tbbox.hit,
                                                                       tbbox.wit))
      hwit = tbbox.hit
      zoom = tbbox.zoom
      # passed nwlat,  nwlon, were for *center* of region
      (nwlat, nwlon) = tbbox.dnwlatlon()
      (selat, selon) = tbbox.dselatlon()
      return (nwlat, nwlon, selat, selon)
#+END_SRC

#+RESULTS: testcalcs

#+BEGIN_SRC python :var zoom=0 :var nwlon=-146.25 :var nwlat=55.777 :var parms=parameters :results output verbatim
  <<testcalcs>>
  hwit = None
  p = {}
  for i in parms:
      p[i[0]] = i[1]

  bytbbox = calcbytbbox(nwlat, nwlon, zoom) # need to do this first to set hwit
  byalgo = calcbyalgorith(nwlat, nwlon, zoom)

  print "nwlat, nwlon, zoom, hwit: ", (nwlat, nwlon, zoom, hwit)
  print "diff by tbbox: ", bytbbox, diffs(bytbbox)
  print "diff by algorithm: ", byalgo, diffs(byalgo)
  print
  second = calcbytbbox(bytbbox[0], bytbbox[1], zoom)
  print "2nd diff by tbbox: ", bytbbox, diffs(second)

#+END_SRC

#+RESULTS:
#+begin_example
dnwlatlon at input:  7 4 3
dnwlatlon returning:  (mlat, mlon), mlatrad, wlatrad, (wlat, wlon):  (0.0, 2.356194490192345) 0.0 0.0 (0.0, 2.356194490192345)
(0.0, 2.356194490192345)
(mlat, mlon), mlatrad, wlatrad, (wlat, wlon):  (0.0, 2.356194490192345) 0.0 0.0 (0.0, 2.356194490192345)
(mlat, mlon), mlatrad, wlatrad, (wlat, wlon):  (-1.5707963267948966, -3.141592653589793) -0.0274155677808 -0.0274121341082 (-1.5705995918442692, -3.141592653589793)
perytile, perxtile:  21.262775 45.0
nwlat, nwlon, zoom, hwit:  (55.777, -146.25, 3, 5)
diff by tbbox:  (0.0, 2.356194490192345, -1.5705995918442692, -3.141592653589793) (1.5705995918442692, 5.497787143782138)
diff by algorithm:  (55.777, -146.25, -50.53687500000001, 78.75) (106.31387500000001, -225.0)

dnwlatlon at input:  5 2 3
dnwlatlon returning:  (mlat, mlon), mlatrad, wlatrad, (wlat, wlon):  (1.5707963267948966, 0.7853981633974483) 0.0274155677808 0.0274121341082 (1.5705995918442692, 0.7853981633974483)
(1.5705995918442692, 0.7853981633974483)
(mlat, mlon), mlatrad, wlatrad, (wlat, wlon):  (1.5707963267948966, 0.7853981633974483) 0.0274155677808 0.0274121341082 (1.5705995918442692, 0.7853981633974483)
(mlat, mlon), mlatrad, wlatrad, (wlat, wlon):  (-2.356194490192345, -1.5707963267948966) -0.0411233516712 -0.0411117657466 (-2.355530665607849, -1.5707963267948966)
2nd diff by tbbox:  (0.0, 2.356194490192345, -1.5705995918442692, -3.141592653589793) (3.9261302574521184, 2.356194490192345)
#+end_example

#+BEGIN_SRC python :results output verbatim
  <<slippymaps>>

  wlat = 35
  wlon = -163
  zoom = 5

  mlat, mlon = wgs2merc(wlat, wlon)

  back2wlat, back2wlon = merc2wgs(mlat, mlon)

  print (wlat-back2wlat, wlon-back2wlon)

  tilex, tiley = merclatlon2tilexy(mlat, mlon, zoom)

  back2mlat, back2mlon = tilexy2nwmerclatlon(tilex, tiley, zoom)

  # here, we expect some offset, since we're getting back the NW corner
  # of the enclosing tile

  # print "(mlat, mlon), (back2mlat, back2mlon), (diff): ", (mlat, mlon), (back2mlat, back2mlon), (mlat-back2mlat, mlon-back2mlon)
  print "(diff): ", (mlat-back2mlat, mlon-back2mlon)

  tilex2, tiley2 = merclatlon2tilexy(back2mlat, back2mlon, zoom)
  back2mlat2, back2mlon2 = tilexy2nwmerclatlon(tilex2, tiley2, zoom)

  print "(back2mlat, back2mlon), (back2mlat2, back2mlon2): ", (back2mlat, back2mlon), (back2mlat2, back2mlon2)
  print "(diff): ", (back2mlat-back2mlat2, back2mlon-back2mlon2)

#+END_SRC

#+RESULTS:
#+begin_example
merc2wgs (mlat, mlon), mlatrad, wlatrad, (wlat, wlon):  (37.404780729700335, -163) 0.65283657972 0.610865238198 (35.0, -163)
(0.0, 0)
merclatlon2tilexy (mlat, mlon, zoom), (tilex, tiley): 
(37.404780729700335, -163, 5) (1.0, 12.0)
tilexy2nwmerclatlon (tilex, tiley, zoom), (mlat, mlon):  (1.0, 12.0, 5) (0.7853981633974483, -2.945243112740431)
(diff):  (36.61938256630289, -160.05475688725957)
merclatlon2tilexy (mlat, mlon, zoom), (tilex, tiley): 
(0.7853981633974483, -2.945243112740431, 5) (15.0, 15.0)
tilexy2nwmerclatlon (tilex, tiley, zoom), (mlat, mlon):  (15.0, 15.0, 5) (0.19634954084936207, -0.19634954084936207)
(back2mlat, back2mlon), (back2mlat2, back2mlon2):  (0.7853981633974483, -2.945243112740431) (0.19634954084936207, -0.19634954084936207)
(diff):  (0.5890486225480862, -2.7488935718910685)
#+end_example

