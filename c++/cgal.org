#+title: work with CGAL
#+property: noweb tangle
#+property: header-args :flags -lCGAL -lgmp -lmpfr  -lboost_thread -L/sw/lib -L/sw/opt/boost-1_58/lib -I/sw/include -I/sw/opt/boost-1_58/include  -I~/src/import/cgal/CGAL-4.8.1/

to get [[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-C.html][c++]], you *enable* C, then *say* C++

[[www.cems.uvm.edu/~rsnapp/teaching/cs274/src/triangles/triangles.html][this site]] has nice examples of using tangled web, org-mode, cgal.

#+name: caution
#+begin_src text
CAUTION: The content of this file is automatically generated by Emacs orgmode
from the file triangles.org that should either be in this, or the parent
directory. Consequently, any modifications made to this file will likely be
ephemeral. Please edit cgal.org instead.
#+end_src


#+BEGIN_SRC C++
// <<caution>>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Polygon_2.h>
#include <iostream>
typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef K::Point_2 Point;
typedef CGAL::Polygon_2<K> Polygon_2;
using std::cout; using std::endl;
int main()
{
  Point points[] = { Point(0,0), Point(5.1,0), Point(1,1), Point(0.5,6)};
  Polygon_2 pgn(points, points+4);
  // check if the polygon is simple.
  cout << "The polygon is " <<
    (pgn.is_simple() ? "" : "not ") << "simple." << endl;
  // check if the polygon is convex
  cout << "The polygon is " <<
    (pgn.is_convex() ? "" : "not ") << "convex." << endl;
  cout << pgn << endl;
  return 0;
}
#+END_SRC

#+RESULTS:
| The | polygon | is | simple. |         |   |   |     |   |
| The | polygon | is | not     | convex. |   |   |     |   |
| 4   | 0       | 0  | 5.1     |       0 | 1 | 1 | 0.5 | 6 |


[[http://www.ics.uci.edu/~dock/manuals/cgal_manual/Convex_hull_2_ref/Function_ch_graham_andrew.html][ch_graham_andrew]] builds a convex hull ccw of a set of points.  this
shows how an std::istream_iterator can be used to cons up a bunch of
points from standard in, writing the output points to standard out.

#+name: ch_graham_andrew
#+BEGIN_SRC C++ :cmdline < /Users/minshall/src/import/cgal/CGAL-4.8.1/examples/Convex_hull_2/ch_from_cin_to_cout.cin
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/ch_graham_andrew.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef K::Point_2 Point_2;

int main()
{
  CGAL::set_ascii_mode(std::cin);
  CGAL::set_ascii_mode(std::cout);
  std::istream_iterator< Point_2 >  in_start( std::cin );
  std::istream_iterator< Point_2 >  in_end;
  std::ostream_iterator< Point_2 >  out( std::cout, "\n" );
  CGAL::ch_graham_andrew( in_start, in_end, out );
  return 0;
}
#+end_src

:ch_graham_andrew_results:
#+RESULTS: ch_graham_andrew
|    7 | 3861 |
|   16 | 3750 |
|   39 | 3540 |
|  214 | 2814 |
|  541 | 2072 |
|  601 | 1962 |
| 1004 | 1462 |
| 1549 |  894 |
| 1672 |  801 |
| 1915 |  640 |
| 2314 |  413 |
| 2642 |  269 |
| 3158 |  110 |
| 3487 |   58 |
| 4294 |   23 |
| 4744 |   53 |
| 5887 |  415 |
| 6048 |  499 |
| 6928 | 1142 |
| 7075 | 1306 |
| 7280 | 1548 |
| 7637 | 2051 |
| 8020 | 2942 |
| 8065 | 3113 |
| 8174 | 4474 |
| 8053 | 5151 |
| 7884 | 5617 |
| 7812 | 5808 |
| 7783 | 5877 |
| 7629 | 6167 |
| 7201 | 6764 |
| 7146 | 6828 |
| 6917 | 7037 |
| 5981 | 7731 |
| 5492 | 7943 |
| 5357 | 7992 |
| 4614 | 8158 |
| 4356 | 8170 |
| 3704 | 8171 |
| 3420 | 8123 |
| 2711 | 7939 |
| 2411 | 7824 |
| 2298 | 7773 |
| 1909 | 7558 |
| 1643 | 7366 |
| 1495 | 7247 |
| 1304 | 7087 |
| 1155 | 6936 |
|  910 | 6660 |
|  756 | 6438 |
|  509 | 6045 |
|  406 | 5869 |
|  172 | 5208 |
|  156 | 5153 |
|   32 | 4395 |
:end:

here is [[http://homepages.math.uic.edu/~ddumas/teaching/2014/spring/mcs481/cgal-example/][an example]] on how to visualize cgal output using [[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html][gnuplot]].

#+BEGIN_SRC gnuplot :var data=ch_graham_andrew :results file
set term png
set output "output.png"
set title "Convex Hull"
set size square
set key off
set xrange [-1000:9000]
set yrange [-1000:9000]
plot data w p ls 3, "" w l
#+END_SRC

from a cgal [[http://www.ics.uci.edu/~dock/manuals/cgal_manual/Polygon/Chapter_main.html#Section_2][example]]

#+name: polygon_example
#+BEGIN_SRC C++ :cmdline < ./polypoints.txt
// file: examples/Polygon/Polygon.C

#include <CGAL/Cartesian.h>
#include <CGAL/Polygon_2.h>
#include <iostream>

typedef CGAL::Cartesian<double> K;
typedef K::Point_2 Point_2;
typedef CGAL::Polygon_2<K> Polygon_2;
using std::cout; using std::endl;

int main()
{
  CGAL::set_ascii_mode(std::cin);
  CGAL::set_ascii_mode(std::cout);
  std::istream_iterator<Point_2> in_start(std::cin);
  std::istream_iterator<Point_2> in_end;
  Polygon_2 pgn(in_start, in_end);

  // check if the polygon is simple.
  cout << "The polygon is " << 
    (pgn.is_simple() ? "" : "not ") << "simple." << endl;

  // check if the polygon is convex
  cout << "The polygon is " << 
    (pgn.is_convex() ? "" : "not ") << "convex." << endl;

  return 0;
}
#+end_src

now, we try some [[http://doc.cgal.org/latest/Boolean_set_operations_2/index.html#Chapter_2D_Regularized_Boolean_Set-Operations][boolean operations]] on polygons.  for our
multigeometries, we'll want to use [[http://doc.cgal.org/latest/Boolean_set_operations_2/classCGAL_1_1Polygon__set__2.html][Polygon_set_2<Kernel, Container,
Dcel>]]

#+BEGIN_SRC C++
#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
#include <CGAL/Polygon_2.h>
#include <CGAL/Polygon_with_holes_2.h>
#include <CGAL/Polygon_set_2.h>
#include <list>
typedef CGAL::Exact_predicates_exact_constructions_kernel Kernel;
typedef Kernel::Point_2                                   Point_2;
typedef CGAL::Polygon_2<Kernel>                           Polygon_2;
typedef CGAL::Polygon_with_holes_2<Kernel>                Polygon_with_holes_2;
typedef CGAL::Polygon_set_2<Kernel>                       Polygon_set_2;
#include </Users/minshall/src/import/cgal/CGAL-4.8.1/examples/Boolean_set_operations_2/print_utils.h>
int main ()
{
  // Construct the two initial polygons and the clipping rectangle.
  Polygon_2 P;
  P.push_back (Point_2 (0, 1));
  P.push_back (Point_2 (2, 0));
  P.push_back (Point_2 (1, 1));
  P.push_back (Point_2 (2, 2));
  Polygon_2 Q;
  Q.push_back (Point_2 (3, 1));
  Q.push_back (Point_2 (1, 2));
  Q.push_back (Point_2 (2, 1));
  Q.push_back (Point_2 (1, 0));
  Polygon_2 rect;
  rect.push_back (Point_2 (0, 0));
  rect.push_back (Point_2 (3, 0));
  rect.push_back (Point_2 (3, 2));
  rect.push_back (Point_2 (0, 2));
  // Perform a sequence of operations.
  Polygon_set_2 S;
  S.insert (P);
  S.join (Q);                   // Compute the union of P and Q.
  S.complement();               // Compute the complement.
  S.intersection (rect);        // Intersect with the clipping rectangle.
  // Print the result.
  std::list<Polygon_with_holes_2> res;
  std::list<Polygon_with_holes_2>::const_iterator it;
  std::cout << "The result contains " << S.number_of_polygons_with_holes()
            << " components:" << std::endl;
  S.polygons_with_holes (std::back_inserter (res));
  for (it = res.begin(); it != res.end(); ++it) {
    std::cout << "--> ";
    print_polygon_with_holes (*it);
  }
  return 0;
}
#+END_SRC

#+RESULTS:
| The  | result | contains | 2        | components: |           |    |           |          |           |      |      |      |       |      |      |          |           |    |    |          |          |    |    |      |       |    |    |          |          |   |
| -->  | {      | Outer    | boundary | =           | [         | 10 | vertices: | (2       |        2) | (1   |   2) | (0   |    2) | (0   |   1) | (0       |        0) | (1 | 0) | (2       |       0) | (3 | 0) | (3   |    1) | (3 | 2) | ]        |          |   |
| 1    | holes: |          |          |             |           |    |           |          |           |      |      |      |       |      |      |          |           |    |    |          |          |    |    |      |       |    |    |          |          |   |
| Hole | #1     | =        | [        | 12          | vertices: | (3 | 1)        | (1.66667 | 0.333333) | (2   |   0) | (1.5 | 0.25) | (1   |   0) | (1.33333 | 0.333333) | (0 | 1) | (1.33333 | 1.66667) | (1 | 2) | (1.5 | 1.75) | (2 | 2) | (1.66667 | 1.66667) | ] |
| }    |        |          |          |             |           |    |           |          |           |      |      |      |       |      |      |          |           |    |    |          |          |    |    |      |       |    |    |          |          |   |
| -->  | {      | Outer    | boundary | =           | [         |  4 | vertices: | (1       |        1) | (1.5 | 0.5) | (2   |    1) | (1.5 | 1.5) | ]        |           |    |    |          |          |    |    |      |       |    |    |          |          |   |
| 0    | holes: |          |          |             |           |    |           |          |           |      |      |      |       |      |      |          |           |    |    |          |          |    |    |      |       |    |    |          |          |   |
| }    |        |          |          |             |           |    |           |          |           |      |      |      |       |      |      |          |           |    |    |          |          |    |    |      |       |    |    |          |          |   |

