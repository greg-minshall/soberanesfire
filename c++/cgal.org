#+title: work with CGAL
#+property: noweb tangle

need to get cgal programs to compile from the command line.  [[http://homepages.math.uic.edu/~ddumas/teaching/2014/spring/mcs481/cgal-example/][here]] are
some tips:
#+property: header-args :flags -lCGAL -lgmp -lmpfr  -lboost_thread -L/sw/lib -L/sw/opt/boost-1_58/lib -I/sw/include -I/sw/opt/boost-1_58/include  -I~/src/import/cgal/CGAL-4.8.1/

to get [[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-C.html][c++]], you *enable* C, then *say* C++

[[www.cems.uvm.edu/~rsnapp/teaching/cs274/src/triangles/triangles.html][this site]] has nice examples of using tangled web, org-mode, cgal.

#+name: caution
#+begin_src text
CAUTION: The content of this file is automatically generated by Emacs orgmode
from the file triangles.org that should either be in this, or the parent
directory. Consequently, any modifications made to this file will likely be
ephemeral. Please edit cgal.org instead.
#+end_src


#+BEGIN_SRC C++
// <<caution>>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Polygon_2.h>
#include <iostream>
typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef K::Point_2 Point;
typedef CGAL::Polygon_2<K> Polygon_2;
using std::cout; using std::endl;
int main()
{
  Point points[] = { Point(0,0), Point(5.1,0), Point(1,1), Point(0.5,6)};
  Polygon_2 pgn(points, points+4);
  // check if the polygon is simple.
  cout << "The polygon is " <<
    (pgn.is_simple() ? "" : "not ") << "simple." << endl;
  // check if the polygon is convex
  cout << "The polygon is " <<
    (pgn.is_convex() ? "" : "not ") << "convex." << endl;
  cout << pgn << endl;
  return 0;
}
#+END_SRC

#+RESULTS:
| The | polygon | is | simple. |         |   |   |     |   |
| The | polygon | is | not     | convex. |   |   |     |   |
| 4   | 0       | 0  | 5.1     |       0 | 1 | 1 | 0.5 | 6 |


[[http://www.ics.uci.edu/~dock/manuals/cgal_manual/Convex_hull_2_ref/Function_ch_graham_andrew.html][ch_graham_andrew]] builds a convex hull ccw of a set of points.  this
shows how an std::istream_iterator can be used to cons up a bunch of
points from standard in, writing the output points to standard out.

#+name: ch_graham_andrew
#+BEGIN_SRC C++ :cmdline < /Users/minshall/src/import/cgal/CGAL-4.8.1/examples/Convex_hull_2/ch_from_cin_to_cout.cin
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/ch_graham_andrew.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef K::Point_2 Point_2;

int main()
{
  CGAL::set_ascii_mode(std::cin);
  CGAL::set_ascii_mode(std::cout);
  std::istream_iterator< Point_2 >  in_start( std::cin );
  std::istream_iterator< Point_2 >  in_end;
  std::ostream_iterator< Point_2 >  out( std::cout, "\n" );
  CGAL::ch_graham_andrew( in_start, in_end, out );
  return 0;
}
#+end_src

:ch_graham_andrew_results:
#+RESULTS: ch_graham_andrew
|    7 | 3861 |
|   16 | 3750 |
|   39 | 3540 |
|  214 | 2814 |
|  541 | 2072 |
|  601 | 1962 |
| 1004 | 1462 |
| 1549 |  894 |
| 1672 |  801 |
| 1915 |  640 |
| 2314 |  413 |
| 2642 |  269 |
| 3158 |  110 |
| 3487 |   58 |
| 4294 |   23 |
| 4744 |   53 |
| 5887 |  415 |
| 6048 |  499 |
| 6928 | 1142 |
| 7075 | 1306 |
| 7280 | 1548 |
| 7637 | 2051 |
| 8020 | 2942 |
| 8065 | 3113 |
| 8174 | 4474 |
| 8053 | 5151 |
| 7884 | 5617 |
| 7812 | 5808 |
| 7783 | 5877 |
| 7629 | 6167 |
| 7201 | 6764 |
| 7146 | 6828 |
| 6917 | 7037 |
| 5981 | 7731 |
| 5492 | 7943 |
| 5357 | 7992 |
| 4614 | 8158 |
| 4356 | 8170 |
| 3704 | 8171 |
| 3420 | 8123 |
| 2711 | 7939 |
| 2411 | 7824 |
| 2298 | 7773 |
| 1909 | 7558 |
| 1643 | 7366 |
| 1495 | 7247 |
| 1304 | 7087 |
| 1155 | 6936 |
|  910 | 6660 |
|  756 | 6438 |
|  509 | 6045 |
|  406 | 5869 |
|  172 | 5208 |
|  156 | 5153 |
|   32 | 4395 |
:end:

here is [[http://homepages.math.uic.edu/~ddumas/teaching/2014/spring/mcs481/cgal-example/][an example]] on how to visualize cgal output using [[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html][gnuplot]].

#+name: gnuplotit
#+BEGIN_SRC gnuplot :var data=ch_graham_andrew :results file
set term png
set output "output.png"
set title "Convex Hull"
set size square
set key off
unset border
plot data w lp ls 3, "" w l
#+END_SRC

#+RESULTS: gnuplotit

from a cgal [[http://www.ics.uci.edu/~dock/manuals/cgal_manual/Polygon/Chapter_main.html#Section_2][example]]

#+name: polygon_example
#+BEGIN_SRC C++ :cmdline < ./polypoints.txt
// file: examples/Polygon/Polygon.C

#include <CGAL/Cartesian.h>
#include <CGAL/Polygon_2.h>
#include <iostream>

typedef CGAL::Cartesian<double> K;
typedef K::Point_2 Point_2;
typedef CGAL::Polygon_2<K> Polygon_2;
using std::cout; using std::endl;

int main()
{
  CGAL::set_ascii_mode(std::cin);
  CGAL::set_ascii_mode(std::cout);
  std::istream_iterator<Point_2> in_start(std::cin);
  std::istream_iterator<Point_2> in_end;
  Polygon_2 pgn(in_start, in_end);

  // check if the polygon is simple.
  cout << "The polygon is " << 
    (pgn.is_simple() ? "" : "not ") << "simple." << endl;

  // check if the polygon is convex
  cout << "The polygon is " << 
    (pgn.is_convex() ? "" : "not ") << "convex." << endl;

  return 0;
}
#+end_src

now, we try some [[http://doc.cgal.org/latest/Boolean_set_operations_2/index.html#Chapter_2D_Regularized_Boolean_Set-Operations][boolean operations]] on polygons.  for our
multigeometries, we'll want to use [[http://doc.cgal.org/latest/Boolean_set_operations_2/classCGAL_1_1Polygon__set__2.html][Polygon_set_2<Kernel, Container,
Dcel>]]

#+BEGIN_SRC C++ :results raw
#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
#include <CGAL/Polygon_2.h>
#include <CGAL/Polygon_with_holes_2.h>
#include <CGAL/Polygon_set_2.h>
#include <list>
typedef CGAL::Exact_predicates_exact_constructions_kernel Kernel;
typedef Kernel::Point_2                                   Point_2;
typedef CGAL::Polygon_2<Kernel>                           Polygon_2;
typedef CGAL::Polygon_with_holes_2<Kernel>                Polygon_with_holes_2;
typedef CGAL::Polygon_set_2<Kernel>                       Polygon_set_2;
#include </Users/minshall/src/import/cgal/CGAL-4.8.1/examples/Boolean_set_operations_2/print_utils.h>
int main ()
{
  // Construct the two initial polygons and the clipping rectangle.
  Polygon_2 P;
  P.push_back (Point_2 (0, 1));
  P.push_back (Point_2 (2, 0));
  P.push_back (Point_2 (1, 1));
  P.push_back (Point_2 (2, 2));
  Polygon_2 Q;
  Q.push_back (Point_2 (3, 1));
  Q.push_back (Point_2 (1, 2));
  Q.push_back (Point_2 (2, 1));
  Q.push_back (Point_2 (1, 0));
  Polygon_2 rect;
  rect.push_back (Point_2 (0, 0));
  rect.push_back (Point_2 (3, 0));
  rect.push_back (Point_2 (3, 2));
  rect.push_back (Point_2 (0, 2));
  // Perform a sequence of operations.
  Polygon_set_2 S;
  S.insert (P);
  S.join (Q);                   // Compute the union of P and Q.
  S.complement();               // Compute the complement.
  S.intersection (rect);        // Intersect with the clipping rectangle.
  // Print the result.
  std::list<Polygon_with_holes_2> res;
  std::list<Polygon_with_holes_2>::const_iterator it;
//  std::cout << "The result contains " << S.number_of_polygons_with_holes()
//            << " components:" << std::endl;
  S.polygons_with_holes (std::back_inserter (res));
//  for (it = res.begin(); it != res.end(); ++it) {
//    std::cout << "--> ";
//    print_polygon_with_holes (*it);
//  }
  std::cout << rect;
  return 0;
}
#+END_SRC

#+RESULTS:
4 0 0 3 0 3 2 0 2


#+name: pgon
| 2 | 2 |
| 1 | 2 |
| 0 | 2 |
| 0 | 1 |
| 0 | 0 |
| 1 | 0 |
| 2 | 0 |
| 3 | 0 |
| 3 | 1 |
| 3 | 2 |

#+call: gnuplotit(data=pgon)

#+RESULTS:

so, we should output the polygons in some format.  [[https://en.wikipedia.org/wiki/Well-known_text][Well known text
(WKT)]] is probably what we want.  is [[http://docs.opengeospatial.org/is/12-063r5/12-063r5.html][this]] the official standard?

[[http://svn.osgeo.org/postgis/trunk/doc/bnf-wkt.txt][here]] is the BNF.  the main things:
#+BEGIN_EXAMPLE
<well-known text representation> ::= 
    <point text representation> | 
    <curve text representation> |
    <surface text representation> |
    <collection text representation>
<collection text representation> ::= 
    <multipoint text representation> | 
    <multicurve text representation> | 
    <multisurface text representation> | 
    <geometrycollection text representation>
<multisurface text representation> ::= 
    MULTISURFACE [ <z m> ] <multisurface text> | 
    <multipolygon text representation> |
    <polyhedralsurface text representation> |
    <tin text representation>
<geometrycollection text representation> ::= 
    GEOMETRYCOLLECTION [ <z m> ] <geometrycollection text>
<geometrycollection text> ::= 
    <empty set> | 
    <left paren> <well-known text representation> { <comma> <well-known text representation> }... <right paren>
<multipolygon text representation> ::= 
    MULTIPOLYGON [ <z m> ] <multipolygon text>
<multipolygon text> ::= 
    <empty set> | 
    <left paren> <polygon text body> { <comma> <polygon text body> }... <right paren>
<polygon text body> ::= 
    <polygon text>
<polygon text> ::= 
    <empty set> | 
    <left paren> <linestring text> { <comma> <linestring text> }... <right paren>
<linestring text> ::= 
    <empty set> | 
    <left paren> <point> { <comma> <point> }... <right paren>
<point> ::= <x> <y> [ <z> ] [ <m> ] 
<x> ::= <number> 
<y> ::= <number>
<z> ::= <number>
<m> ::= <number>
#+END_EXAMPLE

[[http://gis.stackexchange.com/q/54870][here's]] where i see how to get (something like) WKT out of ogr2ogr(1).
the actual command is, e.g.,
#+BEGIN_EXAMPLE
ogr2ogr -f CSV out.wkt ~/work/gis/play/IR/20160807_Soberanes_IR/doc.kml -lco GEOMETRY=AS_WKT
#+END_EXAMPLE
"geometry=as_wkt" is discussed [[http://gdal.org/1.11/ogr/drv_csv.html][here]].  [[http://cartometric.com/blog/2011/11/18/ogr2ogr-export-well-known-text-wkt-for-one-feature-to-a-csv-file/][also]], ogrinfo(1) gives something
similar, but need more parsing.
